[{"categories":["HTML"],"content":"HTML + JS 的一个 弹窗 .","date":"2017-03-06","objectID":"/javascript-modal/","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"HTML + JS 的一个 弹窗 ","date":"2017-03-06","objectID":"/javascript-modal/:0:0","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"代码结构 ","date":"2017-03-06","objectID":"/javascript-modal/:1:0","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"html \u003cdiv id='one'\u003e \u003cbutton id='btn'\u003e点我\u003c/button\u003e \u003c/div\u003e \u003cdiv id='two'\u003e \u003cbutton id='btn'\u003e不要点我\u003c/button\u003e \u003c/div\u003e \u003cdiv id='three'\u003e \u003cbutton id='btn'\u003e我是第三个\u003c/button\u003e \u003c/div\u003e ","date":"2017-03-06","objectID":"/javascript-modal/:1:1","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"css * { margin: 0; padding: 0; } .overlay { width: 100%; height: 100%; background: rgba(0, 0, 0, 0.3); position: fixed; left: 0; top: 0; } .floatwin { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; background: #FFF; left: 50%; border-radius: 4px; } .clear:after { content: ''; display: block; clear: both; } .header { padding: 8px 10px; border-bottom: 1px solid #ccc; } .header\u003espan { float: right; margin: 0; cursor: pointer; } .content { padding: 20px 10px; } .content\u003ep { line-height: 1.5; } .footer { border-top: 1px solid #ddd; padding: 0px 10px; } .footer\u003espan { display: inline-block; float: right; margin: 10px 0px 10px 10px; cursor: pointer; } ","date":"2017-03-06","objectID":"/javascript-modal/:1:2","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"js var Modal = (function () { function _Modal(ct, header, content) { this.ct = ct this.header = header this.content = content this.init() this.bind() } _Modal.prototype = { init: function () { var div = this.div = document.createElement('div') div.innerText = '1' this.html = '\u003cdiv class=\"overlay dis close\"\u003e' this.html += '\u003cdiv class=\"floatwin \"\u003e' this.html += '\u003cdiv class=\"header clear\"\u003e' this.html += '\u003cspan class=\"close\"\u003eX\u003c/span\u003e' this.html += '\u003ch4\u003e' + this.header + '\u003c/h4\u003e' this.html += '\u003c/div\u003e' this.html += '\u003cdiv class=\"content\"\u003e' this.html += '\u003cp\u003e' + this.content + '\u003c/p\u003e' this.html += '\u003c/div\u003e' this.html += '\u003cdiv class=\"footer clear\"\u003e' this.html += '\u003cspan\u003e确定\u003c/span\u003e' this.html += '\u003cspan class=\"close\"\u003e取消\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e' div.innerHTML = this.html console.log(this.html) }, bind: function () { var _this = this console.log(this.ct.querySelectorAll('.close').length) this.ct.querySelector('#btn').addEventListener('click', function (e) { e.stopPropagation(); _this.ct.appendChild(_this.div) }) for (i = 0; i \u003c this.div.querySelectorAll('.close').length; i++) { console.log(1) this.div.querySelectorAll('.close')[i].addEventListener('click', function (e) { e.stopPropagation(); console.log(1) _this.div.parentNode.removeChild(_this.div) }) } this.div.querySelector('.floatwin').addEventListener('click', function (e) { e.stopPropagation(); }) } } return { add: function (ct, header, content) { new _Modal(ct, header, content) } } })() Modal.add(document.querySelector('#one'), '标题啦', '内容啦') Modal.add(document.querySelector('#two'), '标题啦2', '内容啦2') Modal.add(document.querySelector('#three'), '标题啦3', '内容啦4') ","date":"2017-03-06","objectID":"/javascript-modal/:1:3","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["ESLint"],"content":"React ESLint","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":"前端react项目，不管是用create-react-app 初始化的，还是用阿里的 umi 初始化项目，原则上开发语言都要用typescript，所以相关的eslint 和 prettier配置都要加入ts的相关检测特征。为了简化繁琐的配置，使用umi封装的@umijs/fabric 包对 eslint stylelint和prettier的初始配置做了封装，可初始化一些预设配置。 相关的 文档可参考 ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:0:0","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":"配置的步骤如下： 安装 @umijs/fabric、eslint、stylelint、prettier、typescript npm i @umijs/fabric eslint stylelint typescript prettier -D ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:0","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":".eslintrc.js文件配置 module.exports = { extends: [require.resolve('@umijs/fabric/dist/eslint')], // in antd-design-pro globals: { ANT_DESIGN_PRO_ONLY_DO_NOT_USE_IN_YOUR_PRODUCTION: true, page: true, }, rules: { // 自定义的其他配置 }, }; ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:1","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":".stylelintrc.js文件配置 module.exports = { extends: [require.resolve('@umijs/fabric/dist/stylelint')], rules: { // 自定义的其他配置  }, }; ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:2","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":".prettierrc.js文件配置 const fabric = require('@umijs/fabric'); module.exports = { ...fabric.prettier, }; ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:3","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":".editorconfig文件配置 # http://editorconfig.org root = true [*] indent_style = space indent_size = 2 end_of_line = lf charset = utf-8 trim_trailing_whitespace = true insert_final_newline = true [*.md] trim_trailing_whitespace = false [Makefile] indent_style = tab ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:4","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":"tsconfig.json文件配置 { \"compilerOptions\": { \"outDir\": \"build/dist\", \"module\": \"esnext\", \"target\": \"esnext\", \"lib\": [\"esnext\", \"dom\"], \"sourceMap\": true, \"baseUrl\": \".\", \"jsx\": \"preserve\", \"allowSyntheticDefaultImports\": true, \"moduleResolution\": \"node\", \"forceConsistentCasingInFileNames\": true, \"noImplicitReturns\": true, \"suppressImplicitAnyIndexErrors\": true, \"noUnusedLocals\": true, \"allowJs\": true, \"skipLibCheck\": true, \"experimentalDecorators\": true, \"strict\": true, \"noImplicitAny\": false, \"paths\": { \"@/*\": [\"./src/*\"], \"@@/*\": [\"./src/.umi/*\"] }, \"resolveJsonModule\": true }, \"include\": [ \"mock/**/*\", \"src/**/*\", \"tests/**/*\", \"test/**/*\", \"__test__/**/*\", \"typings/**/*\", \"config/**/*\", \".eslintrc.js\", \".stylelintrc.js\", \".prettierrc.js\", \"jest.config.js\", \"mock/*\" ], \"exclude\": [\"node_modules\", \"build\", \"dist\", \"scripts\", \"src/.umi/*\", \"webpack\", \"jest\"] } ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:5","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["ESLint"],"content":"VSCODE编辑器的相关配置 检查vscode中eslint和prettier插件是否正确安装（注意，eslint一定要安装正确的版本，注意作者是Dirk Baeumer) https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode 打开vscode命令行,输入json,打开工作区设置（只针对当前项目） 添加如下配置： { \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true } } 保存后即可生效。 ","date":"2021-03-16","objectID":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/:1:6","tags":["JavaScript","React","VS Code"],"title":"开发react项目代码格式和校验规范","uri":"/%E5%BC%80%E5%8F%91react%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%A0%A1%E9%AA%8C%E8%A7%84%E8%8C%83/"},{"categories":["node"],"content":"node NestJs","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"NestJS Nest官网 Nest (NestJS) 是一个用于构建高效、可扩展的 Node.js 服务器端应用程序的开发框架。它利用 JavaScript 的渐进增强的能力，使用并完全支持 TypeScript （仍然允许开发者使用纯 JavaScript 进行开发），并结合了 OOP （面向对象编程）、FP （函数式编程）和 FRP （函数响应式编程）。 在底层，Nest 构建在强大的 HTTP 服务器框架上，例如 Express （默认），并且还可以通过配置从而使用 Fastify ！ Nest 在这些常见的 Node.js 框架 (Express/Fastify) 之上提高了一个抽象级别，但仍然向开发者直接暴露了底层框架的 API。这使得开发者可以自由地使用适用于底层平台的无数的第三方模块。 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:0:0","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Nest有三种基本的应用程序构建块 模块 @Module({}) ，提供元数据 控制器 @Controller()，处理HTTP请求 组件 @Component()，几乎所有的事物都可以被看作一个组件–Service, Repository, Provider等。 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:0","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"核心文件 app.controller.ts：单路径的简单的控制器 app.module.ts：项目的root模块 main.ts：项目的入口文件，创建nest应用 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:1","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"数据库 安装typeorm,mysql：npm install --save @nestjs/typeorm typeorm mysql 配置：ormconfig.json 注入：app.module.ts 定义实体：entities/**.entity.ts ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:2","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Controller 创建：nest g controller taskList 请求方法：@Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(), @All() 状态码：@HttpCode（200），@HttpCode（404） 自定义请求Header：@Header(‘Cache-Control’, ‘none’) ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:3","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Provider @Injectable() 几乎所有的东西都可以被认为是提供者 - service, repository, factory, helper 等,通过 constructor 注入依赖关系 service： 创建：nest g service tasklist ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:4","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"module @module({ provider`s:[] //引入并实例化的provider，并且可以至少在整个module中共享，service controllers:[AppController,...] //必须创建的一组controllers imports:[] //导入的其他模块的列表，这些模块导出了该模块中所需的provider exports：[] `// 本模块导出的provider，可以被其他导入该模块的文件使用 }) 创建：nest g module tasklist 用处：组织应用程序结构 功能模块：每个功能模块中有一个module，组织该功能的controllers，services，components并输出，在根目录的app.module.ts中引入。 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:5","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Middleware 在路由处理之前被调用，用于修改请求/响应对象、周期 不能在@module()列出，需使用configure()设置 全局中间件：main.ts中app.use() ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:6","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Exception filters 异常过滤器：捕获 HttpException 类的实例，并为它们设置自定义响应逻辑，@Catch(HttpException) 使用范围：路由、controller、全局 捕获一切异常：自定义异常过滤器 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:7","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Pipes 将输入数据转换为所需的输出，可以处理验证 @UsePipes( )，app.useGlobalPipes( ) whitelist：白名单，过滤在dto中未定义的字段，app.useGlobalPipes({whitelist：true}) 两个内置pipes 1. validationPipe： @UsePipes()绑定 创建dto时使用typeScript验证：安装插件 $ npm i –save class-validator * class-transformer 可全局配置，使用时只需在dto中标明类型 2. ParseIntPipe 将一个字符串解析为一个整数值 用于格式化转换前端传入的参数 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:8","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"Serialization @Exclude()：返回数据去掉该字段，password @Expose()：返回数据中加入该字段，不存在在数据库中，由计算得出 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:9","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":["node"],"content":"执行顺序 客户端请求 —\u003e 中间件 —\u003e 守卫 —\u003e 拦截器之前 —\u003e 管道 —\u003e 控制器处理并响应 —\u003e 拦截器之后 —\u003e 过滤器 ","date":"2021-02-15","objectID":"/nestjs%E4%BD%BF%E7%94%A8/:1:10","tags":["JavaScript","node"],"title":"NestJs使用","uri":"/nestjs%E4%BD%BF%E7%94%A8/"},{"categories":[],"content":"关于 ","date":"2020-10-22","objectID":"/about/:0:0","tags":[],"title":"Index","uri":"/about/"},{"categories":[],"content":"关于","date":"2020-10-22","objectID":"/about/:1:0","tags":[],"title":"Index","uri":"/about/"},{"categories":["HTML"],"content":"转载","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"转载： ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:0:0","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"一、前端架构起源 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:1:0","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"为什么会出现前端架构？ 十年前，当前端开发这个工种还很小众的时候，它的定位就是应用层的展示部分。用html、js、css完成几个功能简单的页面。因此，在很小规模的项目中，前端技术要素之间不会产生直接影响，因此无需架构相关的思考。当前端项目达到一定规模后，由于前端语言灵活松散的特性，工程化问题就会暴露出来成为发展瓶颈。之前相对孤立的技术要素彼此之间产生了影响和关联。 要用模块化开发，就必须对应某个模块化框架；用这个框架须对应某个构建工具；要用这个工具就必须使用某个包管理工具…这时候，就需要有人从比较高的角度去梳理、寻找适合自己团队的集成解决方案。这一系列解决问题的工具和手段就是前端架构。 每个前端团队都在打造自己的前端开发体系，通常是一个东拼西凑、逐渐磨合的过程。世上本没有路，走的人多了，便形成了路。在前端开发技术如火如荼的今日，这些过程已经被无数先驱团队踩过，并形成一个个开源解决方案。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:1:1","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"二、前端架构的组成 如果一位面试官问你，你们的业务用什么架构？ 有人回答是：React、Vue或者Angular 也可能是：jQuery或者underscore 再或者什么都不需要：原生 js 顺手动撸一套 或许得分最高的人是拿出了自己珍藏多年的前端技术栈脑图，从头至尾讲一遍： fe-mobile \u003e 前端架构2020 但这些都不是架构，仅仅是架构的组成部分。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:0","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"1、组件框架 架构不等同于框架，更不是类库。 框架是架构的重要组成部分，架构决定框架的选型，框架决定架构的技术路线。架构围绕着框架进行一系列的流程工具建设，从而形成完善自动的开发体系。 组件框架又由以下元素组成： 开发模式：我们如何实现代码的职责分离，以前整个前端是MVC中V这一层，现在前端内部也进行MVC的逻辑细分，现在最流行的MVVM，如Vue.js。 通讯：模块化、组件化是前端推进开发模式过程中的一个过程产物，为了有效的进行组件隔离和独立。比较成熟的比如：消息总线、事件模拟、缓存中转、Flux 模型等等，其中在开源社区最有名的数EventEmitter3。 模板：前端重交互，有Vue 的template，React JSX，还有六七年前流行的 artTemplate等等。 基础类库：常用函数、方法、异步化，有 underscore、lodash等等，核心是为了改善编码生产力。 微前端：如何确保我的遗产代码能平滑的迁移，以及如何确保我在若干年后还能用上时下热门的技术栈？ 目前，主流的组件框架有 React、Vue和小程序。很多上层生态都是基于这三个组件框架或者服务于它们的。很多人喜欢React是因为它是最早的组件化框架，面向对象编程，使用JSX描述模板，有Facebook背书。有人因为担心其开源协议的变化转而选择 Vue，Vue的中文社区非常完善。至于如何抉择就仁者见仁了。小程序的定位是使用微信、QQ、支付宝等平台的客户端能力提升Web体验，但因其缺乏统一标准就需要开发者维护多套代码库来兼容了。当然也出现了如：Taro等代码公用方案。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:1","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"2、工具平台 工具平台是围绕我们研发流程的每一步关键节点建设起来的，是前端工程化的主要生产力。从项目仓库的初始化一直到项目发布上线、运营监控的整个过程都需要一系列的系统来承载和保障。 我们可以从代码管理、研发效率、框架支持、运营支持、运维监控五大方面进行描述，对于当前我们还没有的或者可以介入完善的我会使用红色标注： 2.1 代码管理 代码管理工具Git：不熟悉的同学可以使用可视化工具 SourceTree ，当然对于研发还是使用IDE集成的工具更方便 代码规范工具ESLint：推荐研发同学直接安装IDE插件解决编码时规范约束、自动校正。 模块化工具：推荐使用webpack、rollup，老牌的 Seajs 和 requireJS 几乎被完全弃用。 组件库版本管理：推荐使用 Lerna，用于管理包含多个软件包（package）的 JavaScript 项目 2.2 研发效率 脚手架：这个目前我们还没有，我们可以搭建一套属于自己的脚手架。目标是解决项目初始化、代码目录规范、代码编译、开发调试和打包编译等环节。推荐：vue-cli、create-react-app、以及支持服务端渲染的 Next.js。公司内，我们可以建立一套自己的脚手架流程，目标在制定统一的前端脚手架标准和接入方案，制定基于CLI/GUI的前端工程化工作流程，打造本地开发过程中的项目创建、本地开发、规范检查、快速发布的工作流。 联调体验：旨在解决项目从本地开发到线上维护过程中，环境搭建、接口Mock、抓包联调、产品体验、测试验证、线上抓包等问题，减少大家在非业务逻辑的重复性工作、提升研发效率。这个根据我的观察，目前我们做的已经不错了，一个完善的联调体验应当包含以下一些子工具辅助： nohost（whistle）：特点：浏览器插件、跨平台，可替代Fiddler/Charles。基于 whistle 实现的多用户多环境配置及抓包调试系统，不仅具备 whistle 的所有功能，并在 whistle 基础上扩展了一些功能，且支持多人多环境同时使用，支持mock插件。 nginx基础设施：以提升问题定位效率为初衷，提供染色抓包、全息日志和异常发现的Node.js基础设施。 mock接口管理平台、数据源管理、个人数据存储等。结合whistle插件提供交互界面实现自动拦截请求替换 mock 数据 持续集成：自动化构建-测试-发布工作流，持续、快速、高质量地交付你的产品。屏蔽掉所有研发流程中的繁琐环节，让你聚焦于编码。提供流水线、代码库、凭证管理、环境管理、研发商店等核心服务，多重组合，满足企业不同场景的需求。 重构效率： Sketch 插件：打通协同设计能力，支持多种产出物的设计、分享、储存、调用。 视觉编译：可直接将Sketch设计稿通过机器学习转化为代码。 Web自动化测试：包括小程序性能、性能数据上报、测试用例、puppeteerUI自动化脚本等 国际化：统一公司内 i18n 标准化接入流程 2.3 框架支撑 开发调试：Chrome模拟器、开发者工具Network、Performance TimeLine，whistle抓包请求、数据mock、本地代理、请求/响应模拟等 IDE：推荐使用 VSCode，插件系统非常丰富 组件库： 前端通用组件库：建立在集团品牌之上的一套设计体系。旨在提升团队的合作效率，确保设计和开发效果的一致性，并且保证良好的用户体验。包含PC端、H5，具有Vue和React两套组件支持。 通用组件语言规范CLS：将组件抽象为统一模型，采用跨端的数据交换格式(如JSON)对组件进行标准化描述，与平台、语言、框架无关的组件规范。除以数据形式描述页面由组件构成外，也可用于后台驱动前端界面变化。 前端统一接入层：深度对接公司业务的Node层，适用于服务端渲染，提供业务转发，支持L5/Host 自动降级，接入机都收归到NGW配置统一管理，支持Serverless。基于 Docker和CI，降低开发\u0026运维成本，提高研发效率。 2.4 运维监控 前端监控：包含 Aegis：一站式前端监控解决方案，涵盖了日志上报，错误监控，性能监控，资源测速等功能。支持白名单日志和离线日志！ Sentry：知名的开源错误监控与管理系统，通过二次开发和内部部署在公司内网搭建了一套独立的sentry公用组件。支持微信/邮件告警。使得开发者能第一时间监控错误信息，更好定位和解决线上错误。完备的错误聚类分析与工作流管理，让每一个错误都无所遁形! AlloyData：通用型移动端性能优化分析平台，并希望能够提供极致图表分析能力以满足各种场景的性能分析与对比。 weblog：用于前端在客户端上记录日志及实时捞取日志，分析日志，加速问题定位。 shadow-log：提供一套用户行为帧录制与还原方案，通过对用户行为的录制，收集用户行为信息和界面变化信息，还原用户操作的每一帧界面，为 web产品的运行异常调试，以及对用户行为的研究，提供更直观的方案。 emonitor前端监控SDK：支持多端（web、手Q、微信、iOS/Android webview、微信小程序），接入多套数据平台支撑 2.5 运营支撑 PV/UV：PCG有Monitor，微信增值有德鲁伊。都支持分钟级实时统计 Bi：数据可视化工具 罗盘：支持数据统计、报表配置、多维度数据检索、邮件推送、对比查询和数据分析 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:2","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"3、代码结构 \u0026 开发规范 代码结构跟业务、技术选型的特征和发展都有着密切关系，千人千面。 组件库应该放在哪？组件如何划分？公共组件如何抽离？如何管理版本？ 基础库又应该放在哪？职责如何划分？如何更好地利用 TreeShaking？ 多页应用和单页应用在业务膨胀时如何去组织管理？又应该如何打包发布？ 这些都是我们应该慎重思考的问题。在实操时，应该及早的review项目，避免在历史包袱越来越重时候再去追悔莫及。 这里可以考虑通过完善脚手架CI的方式创建页面、组件、基础库和引用资源，约束业务代码结构规范，避免野蛮生长。 这里引用kp老师抛出的一些问题，给到大家反思自己的代码结构是否足够合理 假设当前的团队放大10倍，业务复杂10倍，当前的代码管理还能跟的上吗？ 如何避免开发人员之间的开发行为耦合？ 如何支撑多特性、多版本的并行？ 主路径按功能、按版本还是按渠道？ 推荐阅读：前端开发体系建设日记，虽然是14年的文章，但有很好的借鉴意思。 不以规矩不成方圆。 规范可帮我们极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮他们快速定位问题，提升效率。 需要关注的是，近几年 TypeScript 的发展越发蓬勃，其优秀的类型强约束和静态编译检查对于大型Web应用的开发具有很强的约束效果。我们所熟知的：VSCode和腾讯文档都是采用 TypeScript 编写的。 注：规范文档和规范约束工具同样重要 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:3","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"4、流程边界 随着移动应用的兴起，很多前端团队开始承担客户端的开发，如：Hybrid开发（微信JSSDK）、跨端框架（Hippy、QQAPI）、客户端预渲染、游戏开发（Cocos、Laya）等； 随着Node的兴起，也有很多前端团队承接后端轻逻辑的开发，如：服务端直出（NGW）、Serverless云函数（云开发framework、SCT、anode）； NW.js、和Electron更是让我们使用JavaScript构建跨平台桌面应用程序的能力，如：VSCode、微信小程序开发工具。其中VSCode更是成为大型Web应用的架构设计标杆，具有非凡的学习参考意义。 这些很多都来自前端团队自发的优化，这种优化需要团队的架构师敢于打破原有的边界，跟大团队一起重新定义新的工作边界，从而形成前端架构领域的放大和寻找更多技术创新的机会。 在研发流程上，我们也可以持续改进。如： 运营平台，让运营同学直接拿设计稿按照自己的需求去上传、配置、验证、发布。可达到每周发布活动上百个。前端团队的架构模型也得到了新的补充。 管理后台也是资源消耗大头，权限管理、配置管理让开发同学成长受限、持续苦恼。通过这些平台的标准化运营操作接口格式和规范以及统一的操作流程让后台开发也可以快速搭建想要的管理界面，不要跟前端沟通和联调。架构优化的价值再次体现。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:4","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"5、核心理念 不同团队的架构模型必然不同，最好的架构一定是最适合团队和业务的架构。 一个架构还需要一个统一的牵引力去影响架构自身的成长迭代，这个牵引力是团队理念。统一的团队理念可以帮助我们在架构演进的过程中形成统一的技术选型、解题思路、价值观念。减少在这个过程中的无谓争执，甚至最后出现“都试一下”这种费时费力不负责任的结论。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:5","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"6、经验沉淀 架构最强大的点在于控制，不怕你写不好代码，它能把风险控制在局部，能够让架构上的功能颗粒自动排列 架构最大的风险在于传承，诞生自少数人手中，但要依赖数代同事进行维护和进化 经验沉淀、理念传承 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:2:6","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"三、前端领域的技术趋势 正如前面流程边界所讲，很多前端成功技术和成果都来自于对原有流程边界的改造。好的架构师不会在既定的框架下苦苦挖掘，在泥坑里打滚。换块空地换个视角，或许可以做的更多。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:3:0","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"1、中台建设 早在18年以前，阿里就开始逐步打造了一整套的中台体系，结合阿里云对外提供服务。具有代表性的前端开源组件库有： Ant Design：一度是国内最流行的中台组件库。以及配套的 AntV：蚂蚁数据可视化包含：G2、F2(支持H5、小程序、Weex、Native)、G6（引擎与图分析工具）、X6、L7等等 但整个中台建设并不仅仅是个组件库就能搞定的，它包含：SOA、微服务、共享服务、中台运营能力、稳定性保障以及服务治理等等。前端作为其中一个重要环节起着可视化、低门槛、提效能等作用。 目前各团队（目测）都在使用不同的自研组件/第三方组件、平台、可视化开发、Severless、云开发、监控体系等等，内部闭环，各自重复造轮子，尚未形成完整体系的共享服务，这个也是可以挖掘的。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:3:1","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"2、跨端动态化方案 近几年来谷歌开源的Flutter框架炒的热火朝天，得益于在iOS和Android双平台使用同一套代码，社区对其评价褒贬不一。 也有很多团队一直在钻研ReactNative，以及基于Vue的Weex。之前在腾讯，也有Hippy团队在持续探索这个生态。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:3:2","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"3、特效和游戏 随着移动端设备性能的提升，平台赋予开发者的表现能力越来越强。从2D到3D，越来越多的游戏引擎，如：Cocos、Laya、白鹭、WebGL，以及WebSAssembly 都赋予我们生产酷炫能力的方法。虽然目前很少有互联网产品考虑用游戏引擎去做，但它绝对是一个令所有人期待和兴奋的点。这里需要关注3个点： Cocos 已经是目前小游戏平台最受欢迎的引擎，占比约70%以上 WebSAssembly技术能让Web运行C/C++语言让Unity有了更大的舞台 Phaser作为国外开源社区做火爆的引擎其源码架构具有非常好的学习借鉴价值（phaser3） ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:3:3","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["HTML"],"content":"四、继续努力 前端是一个高速发展的赛道。由于缺乏标准，前端工程师成了最高产（造轮子）的码农，与此同时也不乏出现很多令人惊艳的技术以及各个团队积累多年的宝贵经验和工具。这些东西都让我们针对前端架构由不同的思考和理解。更有甚者，新的Web标准可能会完全打破现在的技术架构和认知，形成一套新的体系（如 Flutter）。 以上内容可能还有未想到的，欢迎大家一起来补充完善，希望做2021大家可以做一个更好的前端coder。 ","date":"2020-09-25","objectID":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/:4:0","tags":["JavaScript"],"title":"前端知识2020","uri":"/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%862020/"},{"categories":["TS"],"content":"TypeScript","date":"2020-08-11","objectID":"/typescript/","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"1.基础类型 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 ","date":"2020-08-11","objectID":"/typescript/:1:0","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"布尔值 let feng: boolean = false ","date":"2020-08-11","objectID":"/typescript/:1:1","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"数字 let feng: number = 8 ","date":"2020-08-11","objectID":"/typescript/:1:2","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"字符串 let namw: string = 'ming'; let sentence: string = `Hello, my name is ${ name }. ","date":"2020-08-11","objectID":"/typescript/:1:3","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"数组 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组： let list: number[] = [1, 2, 3] 第二种方式是使用数组泛型，Array\u003c元素类型\u003e： let list: Array\u003cnumber\u003e = [1, 2, 3] ","date":"2020-08-11","objectID":"/typescript/:1:4","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 // Declare a tuple type let x: [string, number] // Initialize it x = ['hello', 10] // OK // Initialize it incorrectly x = [10, 'hello'] // Error //当访问一个越界的元素，会使用联合类型替代： x[3] = 'world' // OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString x[6] = true // Error, 布尔不是(string | number)类型 ","date":"2020-08-11","objectID":"/typescript/:1:5","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"枚举 enum 类型是对 JavaScript 标准数据类型的一个补充 enum Color { Red, Green, Blue } let c: Color = Color.Green ","date":"2020-08-11","objectID":"/typescript/:1:6","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"任意值 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： let notSure: any = 4 notSure = 'maybe a string instead' notSure = false // okay, definitely a boolean ","date":"2020-08-11","objectID":"/typescript/:1:7","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"空值 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： function warnUser(): void { alert('This is my warning message') } ","date":"2020-08-11","objectID":"/typescript/:1:8","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"Null 和 Undefined TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大： // Not much else we can assign to these variables! let u: undefined = undefined let n: null = null 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 ","date":"2020-08-11","objectID":"/typescript/:1:9","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"联合类型 let apple: string | number apple = 'key' apple = 98 联合类型表示一个值可以是几种类型之一。 我们用竖线（|）分隔每个类型，所以 number | string | boolean 表示一个值可以是 number，string，或 boolean。 ###类型断言 类型断言有两种形式。 其一是“尖括号”语法： let someValue: any = 'this is a string' let strLength: number = (\u003cstring\u003esomeValue).length 另一个为 as 语法： let someValue: any = 'this is a string' let strLength: number = (someValue as string).length ","date":"2020-08-11","objectID":"/typescript/:1:10","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"2.接口 ","date":"2020-08-11","objectID":"/typescript/:2:0","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"可选属性 interface LabelledValue { label: string width?: number } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label) } let myObj = { size: 10, label: 'Size 10 Object' } printLabel(myObj) ","date":"2020-08-11","objectID":"/typescript/:2:1","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性: interface Point { readonly x: number readonly y: number } 你可以通过赋值一个对象字面量来构造一个 Point。 赋值后，x 和 y 再也不能被改变了。 let p1: Point = { x: 10, y: 20 } p1.x = 5 // error! ","date":"2020-08-11","objectID":"/typescript/:2:2","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"readonly vs const 最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。 ###函数类型 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean } let mySearch: SearchFunc mySearch = function(source: string, subString: string) { let result = source.search(subString) if (result == -1) { return false } else { return true } } //对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 let mySearch: SearchFunc mySearch = function(src: string, sub: string): boolean { let result = src.search(sub) if (result == -1) { return false } else { return true } } ","date":"2020-08-11","objectID":"/typescript/:2:3","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"类类型 interface ClockInterface { currentTime: Date } class Clock implements ClockInterface { currentTime: Date constructor(h: number, m: number) {} } 你也可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样： interface ClockInterface { currentTime: Date setTime(d: Date) } class Clock implements ClockInterface { currentTime: Date setTime(d: Date) { this.currentTime = d } constructor(h: number, m: number) {} } ","date":"2020-08-11","objectID":"/typescript/:2:4","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"扩展接口 和类一样，接口也可以相互扩展。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 interface Shape { color: string } interface Square extends Shape { sideLength: number } let square = \u003cSquare\u003e{} square.color = 'blue' square.sideLength = 10 一个接口可以继承多个接口，创建出多个接口的合成接口。 interface Shape { color: string } interface PenStroke { penWidth: number } interface Square extends Shape, PenStroke { sideLength: number } let square = \u003cSquare\u003e{} square.color = 'blue' square.sideLength = 10 square.penWidth = 5.0 ","date":"2020-08-11","objectID":"/typescript/:2:5","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"3.类 下面看一个使用类的例子： class Greeter { greeting: string constructor(message: string) { this.greeting = message } greet() { return 'Hello, ' + this.greeting } } let greeter = new Greeter('world') ","date":"2020-08-11","objectID":"/typescript/:3:0","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"公共，私有与受保护的修饰符 默认为公有 class Animal { public name: string public constructor(theName: string) { this.name = theName } public move(distanceInMeters: number) { console.log(`${this.name}moved ${distanceInMeters}m.`) } } 理解 private 当成员被标记成 private 时，它就不能在声明它的类的外部访问。比如： class Animal { private name: string constructor(theName: string) { this.name = theName } } new Animal('Cat').name // Error: 'name' is private; 理解 protected protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。例如： class Person { protected name: string constructor(name: string) { this.name = name } } class Employee extends Person { private department: string constructor(name: string, department: string) { super(name) this.department = department } public getElevatorPitch() { return `Hello, my name is ${this.name}and I work in ${this.department}.` } } let howard = new Employee('Howard', 'Sales') console.log(howard.getElevatorPitch()) console.log(howard.name) // error 注意，我们不能在 Person 类外使用 name，但是我们仍然可以通过 Employee 类的实例方法访问，因为 Employee 是由 Person 派生出来的。 readonly 修饰符 你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus { readonly name: string readonly numberOfLegs: number = 8 constructor(theName: string) { this.name = theName } } let dad = new Octopus('Man with the 8 strong legs') dad.name = 'Man with the 3-piece suit' // error! name is readonly. ","date":"2020-08-11","objectID":"/typescript/:3:1","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"4.函数 和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。 你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。 通过下面的例子可以迅速回想起这两种 JavaScript 中的函数： // Named function function add(x, y) { return x + y } // Anonymous function let myAdd = function(x, y) { return x + y } ","date":"2020-08-11","objectID":"/typescript/:4:0","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"typescript 函数类型 为函数定义类型 function add(x: number, y: number): number { return x + y } let myAdd = function(x: number, y: number): number { return x + y } 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 书写完整函数类型 现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。 let myAdd: (x:number, y:number)=\u003enumber = function(x: number, y: number): number { return x+y; }; 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写： let myAdd: (baseValue:number, increment:number) =\u003e number = function(x: number, y: number): number { return x + y; }; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(=\u003e)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void 而不能留空。 ","date":"2020-08-11","objectID":"/typescript/:4:1","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["TS"],"content":"可选参数和默认参数 TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。 function buildName(firstName: string, lastName: string) { return firstName + ' ' + lastName } let result1 = buildName('Bob') // error, too few parameters let result2 = buildName('Bob', 'Adams', 'Sr.') // error, too many parameters let result3 = buildName('Bob', 'Adams') // ah, just right JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 last name 是可选的： function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + ' ' + lastName else return firstName } let result1 = buildName('Bob') // works correctly now let result2 = buildName('Bob', 'Adams', 'Sr.') // error, too many parameters let result3 = buildName('Bob', 'Adams') // ah, just right 可选参数必须跟在必须参数后面。 如果上例我们想让 first name 是可选的，那么就必须调整它们的位置，把 first name 放在后面。 在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把 last name 的默认值设置为\"Smith”。 function buildName(firstName: string, lastName = 'Smith') { return firstName + ' ' + lastName } let result1 = buildName('Bob') // works correctly now, returns \"Bob Smith\" let result2 = buildName('Bob', undefined) // still works, also returns \"Bob Smith\" let result3 = buildName('Bob', 'Adams', 'Sr.') // error, too many parameters let result4 = buildName('Bob', 'Adams') // ah, just right 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。 function buildName(firstName: string, lastName?: string) { // ... } 和 function buildName(firstName: string, lastName = 'Smith') { // ... } 欢迎小伙伴们批评与指正！觉得还行请动动小手点个赞哈👍👍👍 ","date":"2020-08-11","objectID":"/typescript/:4:2","tags":["JavaScript","TS"],"title":"TypeScript","uri":"/typescript/"},{"categories":["其他"],"content":"微前端","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"为什么需要微前端? 我们通过3W(what,why,how)的方式来讲解微前端 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:0","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"What?什么是微前端? 微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。 微前端的核心在于拆, 拆完后在合! ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:1","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"微前端架构具备以下几个核心价值： 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 增量升级 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 独立运行时 每个子应用之间状态隔离，运行时状态不共享 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:2","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"Why?为什么去使用他? 不同团队间开发同一个应用技术栈不同怎么破？ 希望每个团队都可以独立开发，独立部署怎么破？ 项目中还需要老的应用代码怎么破？ 我们是不是可以将一个应用划分成若干个子应用，将子应用打包成一个个的lib。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！从而解决了前端协同开发问题 怎样落地微前端? 2018年 Single-SPA诞生了， single-spa是一个用于前端微服务化的JavaScript前端解决方案 (本身没有处理样式隔离，js执行隔离) 实现了路由劫持和应用加载； 2019年 qiankun基于Single-SPA, 提供了更加开箱即用的 API （single-spa + sandbox + import-html-entry） 做到了，技术栈无关、并且接入简单（像iframe一样简单）； 总结：子应用可以独立构建，运行时动态加载主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount方法） 大家肯定会问的问题： 这不是iframe吗？ 如果使用iframe，iframe中的子应用切换路由时用户刷新页面会丢失当前的页面内容，回到初始话的路由页面，用户体验不好；如果是子应用嵌入到iframe里，刷新页面时，刷的是父应用的路由，此时子页面会丢失。 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:3","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"应用通信方式: 基于URL来进行数据传递，但是传递消息能力弱 基于CustomEvent实现通信 customEvent 基于props主子应用间通信 使用全局变量、Redux进行通信 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:4","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"实现微前端有哪些方案 单纯根据对概念的理解，很容易想到实现微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下： 方案 描述 优点 缺点 Nginx 路由转发 过 Nginx 配置反向代理来实现不同路径映射到不同应用 简单，快速，易配置 在切换应用时会触发浏览器刷新，影响体验 iframe嵌套 父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式 实现简单，子应用之间自带沙箱，天然隔离，互不影响 iframe的样式显示、兼容性等都具有局限性；太过简单而显得low;刷新丢失当前子应用内容 Web Components 每个子应用需要采用纯Web Components技术编写组件，是一套全新的开发模式 每个子应用拥有独立的script和css，也可单独部署 对于历史系统改造成本高，子应用通信较为复杂易踩坑 组合式应用路由分发 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制 纯前端改造，体验良好，可无感知切换，子应用相互隔离 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:5","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"single-spa 在一个 single-spa 页面，注册的应用会经过下载(loaded)、初始化(initialized)、被挂载(mounted)、卸载(unmounted)和unloaded（被移除）等过程。single-spa会通过“生命周期”为这些过程提供钩子函数; 注: bootstrap, mount, and unmount的实现是必须的，unload则是可选的 生命周期函数必须有返回值，可以是Promise或者async函数 如果导出的是函数数组而不是单个函数，这些函数会被依次调用，对于promise函数，会等到resolve之后再调用下一个函数 如果 single-spa 未启动，各个应用会被下载，但不会被初始化、挂载或卸载。 传参 生命周期函数使用\"props” 传参，这个对象包含single-spa相关信息和其他的自定义属性； function bootstrap(props) { const { name, // 应用名称 singleSpa, // singleSpa实例 mountParcel, // 手动挂载的函数 customProps // 自定义属性 } = props; // Props 会传给每个生命周期函数 return Promise.resolve(); } 内置参数 每个生命周期函数的入参都会保证有如下参数： name: 注册到 single-spa 的应用名称 singleSpa: 对singleSpa 实例的引用, 方便各应用和类库调用singleSpa提供的API时不再导入它。 可以解决有多个webpack配置文件构建时无法保证只引用一个singleSpa实例的问题。 mountParcel: mountParcel 函数. 自定义参数 // 父应用 singleSpa.registerApplication({ name: 'app1', activeWhen: ['/myApp', (location) =\u003e location.pathname.startsWith('/some/other/path')], app, customProps: { authToken: \"d83jD63UdZ6RS6f70D0\" } }); singleSpa.registerApplication({ name: 'app1', activeWhen: ['/myApp', (location) =\u003e location.pathname.startsWith('/some/other/path')], app, customProps: (name, location) =\u003e { return { authToken: \"d83jD63UdZ6RS6f70D0\" }; } }); // 子应用 export function mount(props) { console.log(props.authToken); // 可以在 app1 中获取到authToken参数 return vueLifecycles.mount(props); } 可能使用到的场景： 各个应用共享一个公共的 access token 下发初始化信息，如渲染目标 传递对事件总线（event bus）的引用，方便各应用之间进行通信 注意如果没有提供自定义参数，则props.customProps默认会返回一个空对象 ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:6","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"qiankun qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。 主应用搭建 选择用vue-cli初始化了主应用，不了解的可自行阅读官方文档 项目中引入qiankun： 安装 $ yarn add qiankun # 或者 npm i qiankun -S 在主应用中注册微应用 //micro/app.js import shareData from \"./shared\"; /* * name: 微应用名称 - 具有唯一性 * entry: 微应用入口 - 通过该地址加载微应用 * container: 微应用挂载节点 - 微应用加载完成后将挂载在该节点上 * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用 */ const apps = [ { name: \"vueApp\", // 应用的名字 entry: \"//localhost:10000\", // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch container: \"#app-qiankun\", // 容器名 activeRule: \"/vue\", // 激活的路径 props: { appData: shareData, data: \"父应用数据111\" }, }, { name: \"reactApp\", entry: \"//localhost:20000\", // 默认会加载这个html 解析里面的js 动态的执行 （子应用必须支持跨域）fetch container: \"#app-qiankun\", activeRule: \"/react\",//location =\u003e location.pathname.startsWith('/react') props: { appData: shareData, data: \"父应用数据222\" }, }, ]; export default apps; //main/index.js import { registerMicroApps, start } from 'qiankun'; import apps from './micro/app'; registerMicroApps(apps); // 启动微应用 start(); 当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。 配置子应用 微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用。 在主应用配置好注册的微应用后，我们需要对子应用进行配置，让子应用能接入到主应用中。 子应用说明 导出相应的生命周期钩子 微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。 /** * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。 */ export async function bootstrap() { console.log('react app bootstraped'); } /** * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法 */ export async function mount(props) { console.log(props); ReactDOM.render(\u003cApp /\u003e, document.getElementById('react15Root')); } /** * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例 */ export async function unmount() { ReactDOM.unmountComponentAtNode(document.getElementById('react15Root')); } /** * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效 */ export async function update(props) { console.log('update props', props); } ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:7","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["其他"],"content":"注意点 1.为什么微应用加载的资源会 404？ 原因是 webpack 加载资源时未使用正确的 publicPath,两种解决方式： a. 使用 webpack 运行时 publicPath 配置 qiankun 将会在微应用 bootstrap 之前注入一个运行时的 publicPath 变量，你需要做的是在微应用的 entry js 的顶部添加如下代码： if (window.__POWERED_BY_QIANKUN__) { // 动态添加publicPath __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__; } b.使用 webpack 静态 publicPath 配置 关于运行时 publicPath 的技术细节，可以参考 webpack 文档 // webpack.config.js { output: { publicPath: `//localhost:${port}`, } } 2.如何独立运行微应用 有些时候我们希望直接启动微应用从而更方便的开发调试，你可以使用这个全局变量来区分当前是否运行在 qiankun 的主应用的上下文中： if (!window.__POWERED_BY_QIANKUN__) { render(); } 3.配置微应用的打包工具 除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置： const packageName = require('./package.json').name; module.exports = { output: { // 微应用的包名，这里与主应用中注册的微应用名称一致 library: `${packageName}-[name]`, // 将你的 library 暴露为所有的模块定义下都可运行的方式,其实就是将 这个类库挂载到全局的window上 libraryTarget: 'umd', // 按需加载相关，设置为 webpackJsonp_vue-project 即可 jsonpFunction: `webpackJsonp_${packageName}`, }, }; ","date":"2020-07-15","objectID":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/:1:8","tags":["JavaScript"],"title":"微前端框架single Spa和qiankun","uri":"/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6single-spa%E5%92%8Cqiankun/"},{"categories":["转载"],"content":"编程经验","date":"2020-06-21","objectID":"/programming-experience/","tags":["转载"],"title":"转载 - 编程经验谈","uri":"/programming-experience/"},{"categories":["转载"],"content":"编程经验谈 转载自幻神博客 设计 在没有足够多的具体实例之前，先不要急着建立抽象 别做一般性的考虑，先考虑清楚到底要覆盖哪些目标场景 如果你没写过自己的编程语言，那就尽量别碰 DSL 经历比资历重要，除非以前做过，否则大家都是拿不定主意 大部分人并没有十年的编程实战经验，所以要相信自己的判断 不论你设计的多么好，总有人能指出他认为不好的地方 项目 不要乱动别人写的代码，尤其是不要删那些看起来没用的逻辑 项目中遇到的问题，大多不是技术问题，而是人的利益冲突 永远无法兼顾所有人的利益，所以重要是自己决定怎样做 不存在足够好的理想中的团队环境，换一个团队只是换一些问题 项目就是用不完美的办法尽量达成目的的过程，因此总有令人不满意的地方 债务总是会有的，区别是积累一段时间后偿还，还是随时偿还 代码 只靠代码本身，无法进一步提高代码的可读性 可维护性是玄学，人们都认为只有自己的代码才更好维护 好代码是有代价的，洁癖是不可取的，我们需要的不是代码而是功能 把代码写正确，比把代码写优雅更重要 著名项目里的代码，并不比你写的好 不存在看不懂的代码，再烂的代码多少也能看懂一点，静下心来看下去很重要 产品 解决问题的时候，还要关注问题是怎么定义的 问题有时候并不需要被解决，找到提出问题的人 亲手用一用自己的产品，避免“亲爱的用户，我是你爹” 没有该不该做的事情，只有轻重缓急 需求不可能不变，因此不是要禁止变更，而是要对变更进行管控 对于究竟怎样做更好，产品经理有时候也不能确定，只是他必须表现出确定 做事 疼痛需由当事人自己说出来，要关心用户但也不要替别人拿主意 不要勉强采用别人的方案解决问题，自己的事情自己负责，不认可就别接着做 我们都是公司的资源，因此不要以浪费资源的方式开展工作 别人不是反对我们的方案，而是反对我们给他们造成的麻烦 专业技能千篇一律，办事能力千差万别 事情能进展下去，不是因为本身是对的，而是各参与者都能得到自己想要的 学习 程序猿是在帮别人解决问题，而不是自己 开发者的时间不是自己的，公司不是学习的地方 没有纯技术团队，总得做一些不想做的事情 你觉得需要学的，是别人想让你学的 工作不止编程这么简单，不要用十年只学编程 编程是一个不断学习的过程，除了学习通用知识之外，还要学团队成员创造的知识 ","date":"2020-06-21","objectID":"/programming-experience/:0:0","tags":["转载"],"title":"转载 - 编程经验谈","uri":"/programming-experience/"},{"categories":["React"],"content":"React Hooks","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。 要启用 Hook，所有 React 相关的 package 都必须升级到 16.8.0 或更高版本。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:0:0","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"1. 好处 纯函数组件使用react特性 逻辑更清晰 (useEffect) 组件复用 (自定义Hooks) ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:1:0","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"2. 常用Hooks 基础 Hooks：useState，useEffect，useContext 其他 Hooks：useReducer，useCallback，useMemo，useRef，useLayoutEffect，useImperativeHandle，useDebugValue ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:0","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useState 跳过 state 更新：调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。React使用Object.js()对比state是否更新； 把所有 state 都放在同一个 useState 调用中，或是每一个字段都对应一个 useState 调用，这两方式都能跑通。当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。 如果 state 的逻辑开始变得复杂，我们推荐 用 reducer 来管理它，或使用自定义 Hook。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:1","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useEffect 副作用 数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。 分为 需要清除的 和 不需要清除 的。 不需要清除的：比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。 需要清除的：订阅外部数据源，防止内存泄露。 可以看做是componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。 在执行 DOM 更新之后延迟调用。 清除：在 effect 返回一个函数，React 将会在组件卸载的时候调用它，执行清除操作。effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。 依赖列表中有函数，解决方案： 将函数移动到effect内部 将函数移动到组件之外 在 effect 之外调用该函数，并让 effect 依赖于它的返回值（如果你所调用的方法是一个纯计算，并且可以在渲染时调用） 万不得已，将函数加入 effect 的依赖，但 把它的定义包裹 进 useCallback Hook effect 的依赖频繁变化，解决方案： setState 的函数式更新形式 useReducer 把 state 更新逻辑移到 effect 之外 useRef 保存一个变量，然后对它进行读写 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:2","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useLayoutEffect 在浏览器完成布局与绘制之后，会在新一次的渲染之前，延迟调用useEffect。 然而，并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。） useLayoutEffect会在DOM更新之后，浏览器执行绘制之前，同步调用effect，读取 DOM 布局并同步触发重渲染。 useContext 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。 当前的 context 值由上层组件中距离当前组件最近的 \u003cMyContext.Provider\u003e 的 value prop 决定。 子组件在 context 值变化时重新渲染。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:3","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useReducer useState 的进阶版。 使用useReducer替代useState的情况： state 逻辑较复杂且包含多个子值 下一个 state 依赖于之前的 state 给会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:4","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useCallback 返回一个 memoized 回调函数。useCallback(fn, deps) 相当于 useMemo(() =\u003e fn, deps)。 当回调函数作为依赖传递给其他Hooks函数（useEffect）时使用。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:5","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useMemo 通过记住上一次计算结果的方式在多次渲染的之间缓存计算结果，返回一个 memoized 值。 传给 useMemo 的函数是在渲染期间运行的。（依赖值改变时运行） 用处： 缓存复杂的计算结果； 跳过子节点的昂贵的重新渲染； memoized是一种优化技术，主要用于通过存储昂贵的函数调用的结果，并在再次出现相同的输入时，返回缓存的结果，用以加速计算机程序。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:6","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。 返回的 ref 对象在组件的整个生命周期内保持不变。 当 ref 对象内容发生变化时，即变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。 使用： 获取元素 保存任何可变值，其类似于在 class 中使用实例字段的方式 使用一个可变的 ref 手动存储一个布尔值来表示是首次渲染还是后续渲染，然后在你的 effect 中检查这个标识 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:2:7","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"Hook注意事项 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:0","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"使用规则 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用（Hook 在每次渲染时都按照相同的顺序被调用） 只能在 React 的函数组件或自定义Hooks中调用 Hooks。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:1","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"自定义Hooks 自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:2","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"其他 React 使用 Object.is 比较算法 来比较 state。Object.is对数组和对象等引用类型的比较是通过对数组和对象的引用地址的比较实现的，若地址不变，只有内容改变，则认为该数组或对象没有改变。 　Object.is()用于确定两个值是否相同，两个值相同有如下的几种情况： 都是 undefined 都是 null 都是 true 或 false 是长度相同的两个字符串，并且每个序号对应的字符相同 相同的两个对象（两个对象有相同的引用地址） 两个相同的数字： 都是 +0 都是 -0 都是 NaN 都不是0且不是NaN，并且值相同 Object.is与 ==运算符得到的结果不一样。==会在比较之前对符号两边的值进行强制类型转换（当他们类型不同时）。 Object.is与 ===运算符得到的结果也不一样。- 0 === + 0 是 true，而Number.NaN === NaN 是 false。 Hook 能否覆盖 class 的所有使用场景？ 目前暂时还没有对应不常用的 getSnapshotBeforeUpdate，getDerivedStateFromError 和 componentDidCatch 生命周期的 Hook 等价写法。 useCallback，useEffect，useMemo等需要依赖值的hooks，不能在hooks函数里面改变依赖值，否则hooks会无限循环。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:3","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"问题 useMemo 与 useCallBack的区别？ useCallback(fn, deps) 相当于 useMemo(() =\u003e fn, deps) useMemo返回的是函数运行的结果，useCallback返回的是函数 官方建议： 你可以把 useMemo作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。 ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:4","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":["React"],"content":"useMemo和Memo的区别？ memo针对一个组件的渲染是否重复执行 usememo针对一段函数逻辑是否重复执行 当useMemo用于记住组件渲染结果时，与Memo效果一样。 区别： useMemo用于使 component 的部分不要进行 re-render，而不是整个 component 不要 re-render。 React.memo(component, compare)，第二个参数compare(prevProps, nextProps)用于比较props是否变化，如果第二个参数不传递，则默认只会进行 props 的浅比较。 useRef保存变量与useState的区别？ useRef改变时不会触发re-render ","date":"2020-06-15","objectID":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/:3:5","tags":["JavaScript","React"],"title":"React新特性 Hooks","uri":"/react%E6%96%B0%E7%89%B9%E6%80%A7-hooks/"},{"categories":null,"content":"一键将package.json中的模块更新到最新版本","date":"2020-06-02","objectID":"/npm-update/","tags":["npm"],"title":"一键将package.json中的模块更新到最新版本","uri":"/npm-update/"},{"categories":null,"content":"更新依赖 npm i -g npm-check-updates ncu -u npm install ","date":"2020-06-02","objectID":"/npm-update/:0:0","tags":["npm"],"title":"一键将package.json中的模块更新到最新版本","uri":"/npm-update/"},{"categories":["HTML"],"content":"前端路由原理","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["HTML"],"content":"路由的本质 前端路由，并不是真实的网页跳转，和服务器是没有任何交互的，简单来说，就是不同路径，渲染不同的内容或者组件。 ","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:1:0","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["HTML"],"content":"两种实现方式 一般来说，浏览器端路由分为两种，hash路由和history路由。 ","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:2:0","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["HTML"],"content":"hash路由 利用hash实现路由切换，路径后面加上#，如baidu.com/#/foo/bar/baz。 ","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:2:1","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["HTML"],"content":"history路由 url与普通路径没有区别，如baidu.com/foo/bar/baz，利用html5的api来实现路由跳转。 history路由 属性 length 返回一个整数，该整数表示会话历史中元素的数目，包括当前加载的页。 state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态的方式。 方法 back() 返回上一页，和history.go(-1)功能相同。 forward() 前往下一页，和history.go(1)功能相同。 go() 相对于当前页面，去往历史页面的位置。负值表示向后移动，正值表示向前移动。因此，例如：history.go(2)向前移动两页，history.go(-2)则向后移动两页。如果未向该函数传参或传一个0，则该函数与调用location.reload()具有相同的效果。 pushState() history.pushState(state, title[, url]) state是一个对象，它与pushState()创建的新历史记录条目相关联。 每当用户导航到新状态时，都会触发popstate事件，并且该事件的状态属性包含历史记录条目的状态对象的副本。 replaceState() replaceState()方法使用state objects, title,和 URL 作为参数， 修改当前历史记录实体，如果你想更新当前的state对象或者当前历史实体的URL来响应用户的的动作的话这个方法将会非常有用。 onpopstate 在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法，需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。 这里我们需要思考一个问题，平常通过 location.href = ‘baidu.com/foo’ 这种方式来跳转，是会让浏览器重新加载页面并且请求服务器的，但是 history.pushState 的神奇之处就在于它可以让 url 改变，但是不重新加载页面，完全由用户决定如何处理这次 url 改变。因此，这种方式的前端路由必须在支持 histroy API 的浏览器上才可以使用。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton onclick=\"go('/one')\"\u003eone\u003c/button\u003e \u003cbutton onclick=\"go('/two')\"\u003etwo\u003c/button\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003cscript\u003e let root = document.getElementById(\"root\"); function go(pathname){ window.history.pushState(null,null,pathname); console.log(\"location\",location); } window.onpopstate=function(event){ console.log(event); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:2:2","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["HTML"],"content":"hash路由 主要思路是通过window.location.hash来改变hash，然后hashchange进行监听，实现HashRouter、Route、Link、Switch、Redirect、动态路由这些基本功能。 ","date":"2020-04-15","objectID":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:2:3","tags":["JavaScript","HTML"],"title":"路由的基本原理","uri":"/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["读书"],"content":"读书《黑天鹅》","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"《黑天鹅》 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:0:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"规避突发的事件对自身的影响 预防比事后弥补/事中救火要重要的多，对突发事件最坏结果做好预防，降低对正常事件的影响。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:1:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"个人认知的局限性 认知是片面的，局部的，带有局限性。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"静态思维与动态思维 事物处于运动之中。 静态思维容易将过去的，片面的标签来描述现在的事物，而忽略了事物的运动性，发展性，即使是微小的，持续的变化在时间的加持下也能引起质变。例如西方国家对亚非国家的刻板印象。 很多事物往往处于复杂的系统中，事物之间互相影响。所以决策时要运用动态思维考虑决策将会引起的一系列连锁。例如政府新颁布的政策，正所谓上有政策下有对策。 延伸： 对自身认识的高估、对现实情况的低估； 当局时容易盲从。习惯从结果后再推理逻辑，使事件符合所谓因果； 过于依赖所谓权威专家的结论，自己却未进行深层思考辩证。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:1","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"假如你不会预测怎么办 假如你抛弃完全准确地预测未来的想法，你就有很多事情可以做，只要你记住预测的局限性。知道你无法预测，并不意味着你不能从未来的不可预测性中获益。 建议很廉价，非常廉价 作好准备！狭隘的预测有麻痹或治疗的作用。小心那些神奇数字的麻痹作用。对所有可能的结果作好准备。 把生活中美好的偶遇最大化。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:2","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"平均斯坦和极端斯坦 平均斯坦大概就是“一把筷子难折断”这条谚语的同类，团结力量大，集体影响小。 极端斯坦就是木桶理论里的短板效应的亲兄弟啊，意外突如其来，无从总结规律。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:3","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"经验主义和现实世界的复杂性 经验主义就是拿过去已知的东西来解决未知的情况，然而现实世界可能存在的“黑天鹅”可能会把之前所有的所谓逻辑轨道推翻。 向内看到自身的缺陷，向外看到世界的复杂性；所以成熟客观理智的方式是不草率对事物下决定性定论。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:4","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"黑天鹅事件的定义 黑天鹅事件原因: 世界的不确定性，信息不对称，认知有缺陷，决策非理性，系统复杂性。 人们愿意相信更加精确的事情发生概率更高，但按概率来说越精确意味着条件越严苛，应该是概率更小的事件，这就是所谓的精确的错误和模糊的准确。 讲故事比单纯给出一个数字更有效果，故事直观而立体，数字平面且干瘪。 你的肢体语言和表情管理是可以控制别人对你所要表达内容的质量的看法甚至于忽视你目前的不利情势。你的冷静与表露出的淡淡傲然则会给别人留下深刻印象。所以说话的方式成就你的人格魅力。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:5","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"信息是有偏差的 应该从过去的经验和教训中吸取教训，而不是喝过去经验的鸡汤。 历史都是由赢家书写的，我们只看到了他们如何成功，却不去学习失败者为何失败，成功者成功是多因素甚至种种巧合汇聚起来才能成功，而失败则可能有一种原因便可失败。 信息是有偏差的: 在我们进行天分比较时，经常忽略沉默的证据，尤其在那些受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事，但太把它们当回事是不应该的，因为我们并没有看到全部事实。 人们往往根据自己的需要去选择样本，为自己寻找支撑理由和借口。看到的和听到的都是经过过滤后的信息，并不代表事物的真相。 我们能看到政府做了什么，因此歌颂他们，但我们没有看到别的。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:6","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"对于风险的认知 对沉默证据的认识偏差降低了我们对我们在过去招致的风险的认识，尤其是有幸躲过了那些风险的人。你的生命曾遭受严重威胁，但你幸存下来，于是你在事后会低估情况的实际危险性。 短暂的成功可能会让你松懈，其实这次成功真可能是个侥幸，并代表不了什么，如果松懈，很可能在下一次黑天鹅事件中消失，直到人们忘记。 进化是一系列侥幸的成功，有好的，也有不好的。你只看到了好的。但在短期内，哪些真正对你是好的并不明显，当你处在会产生黑天鹅现象的极端斯坦环境下时尤其如此。 当你觉得不知如何选择的时候，可能不选择都比盲目选择更容易避免盲目承担风险。冒险不可怕，可怕的是对结果的多样性毫无意识。 不要高估个人能力和知识，不要低估不确定性的风险。保持谦虚以及不安全感。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:7","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"思维的误区 我们的思维是有惯性的：一旦形成一个观点，我们就很难改变，所以情况对那些推迟形成观点的人更有利。 后视镜视觉：看着后视镜来开车，结果肯定会翻车嘛！这个类比就如看着过去的数据来判断未来的数据。在股票市场就最常见了 来源于信息本身的特性。我已经说过，黑天鹅现象有三个特点：不可预测，影响重大，事后可解释。 1.我们既爱筛选，又爱进行“狭隘”的思考（认知自大）； 2.我们的预测能力被大大高估，许多认为自己能够预测的人实际上不具备这一能力。 所以真正的热爱生活要看到世界的阴暗面，成功的投资要看到负面的东西，真正的积极是在逆境中。 每增加一个变量，系统的复杂性便随之上升，预测的难度便随之增加！ 根据过去预测未来的问题可能比我们已经讨论的问题还要严重，因为相同的过去的数据既可以证明一个理论，又可以同时证明完全相反的理论！如果你明天还活着，这可能意味着你更可能长生不老，或者你更接近死亡。 不要指望一个巨大的幸福会让我们长期快乐，而是不断的来点小确幸。对于痛苦则反之，长痛不如短痛。 一件事情能做的标准是，不是它的结果好到什么程度，而是它的危害能不能承受，换言之，未虑胜先思败。 工作从来都没有真正的稳定性可谈，但能力却是永远保值的。 一个银行职员可能因为没有能力被人工智能淘汰，而有能力的咨询师却可以在种种风险中不断前行。 波动性让人更容易走在舒适区，同时有着更强的抗风险能力。 这也是在同样面临失业时，咨询师可以比公务员银行职员更快走出危机的原因。 做决策时，你只需要了解事件的影响（这是你能知道的），不需要了解事件的可能性（这是你不可能知道的），这一思想就是不确定性的核心思想。我生活的大部分都以它为基础。 无法理解正在发生什么，即从源头开始走错方向，难以预测。认知自大-盲目性+柏拉图式的分类+错误的推理方法。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:8","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"正态分布（钟形曲线）和极端事件 分布性带来健壮性。集中性带来效率性。以最高效率进行组织形式的构建，并投入极高精力维护稳定，却依然不能避免不确定事件的发生。绝对的集中带来的是小概率的超高风险。 正态分布（钟型曲线）有其适用的条件。 一、结果是由多个（越多越好）变量相加而得的； 二、每个变量是独立的，相互之间不能有影响； 三、每个变量对于结果的贡献是有限的； 人的身高就满足以上条件。身高是由至少180个基因共同决定的，这些基因基本是相互独立的，而身高是所有这些因素相加之和。 在正态分布中，极端事件确实是极其罕见的，你真的不必要去为所有可能做准备，否则你根本就承受不了应对的成本。 而当变量之间是不独立的，存在相互影响时，就不是正态分布了，而是幂律分布。幂律分布下，你必须做好准备迎接极端事件，这里就是极端斯坦。 马太效应就是最好的例子，排行榜越是靠前的书，就会有越多的人购买，每一次的购买行为都会受之前销量的影响。 古斯塔夫也说，能有效煽动大众情绪从而领导他们的，不是正确的道理和理论，而是激情、富于感染力的口号，哪怕这口号经不起推敲。 较大不确定性原则就是，一叶障目，不见泰山，只见树木，不见森林。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:9","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"冗余和高效率的矛盾 多策略多计划，备份方案的重要性，防御性冗余: 冗余就意味着保险。尽管看上去有些效率低下，但这是为了维护这些备件，并具备足够的保有这些备件的能量，尽管它们平时处于闲置状态。 所谓高效率，也就是说把冗余去除掉，从而提高了效率，冗余就相当于企业的现金流，现金流充裕，也就可以抵御金融风险了。效率与冗余是对立的，效率高则冗余低 拥有众多辅助功能的东西会从环境任意性和认知不透明性中受益匪浅。 人们更愿意突然性地失去很多，而不愿意每一步失去少量；人们在痛苦到一定程度，会变得麻木。因此，不愉快的经历（比如在新泽西逗留）应当越集中、越浓缩越好。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:10","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"信息的不对称和看待信息角度差异 对于火鸡来说就是黑天鹅现象，但是对于屠夫来说是日常操作。信息的不对称和不同的角度看待问题差别巨大。 就好像计划赶不上变化一样，之前说过的计划与现实的偏离都会有所偏差，时间越长，项目越大，偏差也就越大。 对于不确定性的这种两极分化一种产生的宿命论，一种认为无所谓，而实际上呢，对于这个本体随意性和你的认知随意性的偏差是非常非常大的。 罕见事件发生的频率不能通过经验观察来预测，原因是它们太罕见了。因此，我们需要一个先验模式来代表它；事件越罕见，使用标准的归纳方法（比如通过例数过去发生的事情进行频率抽样）进行预测的错误便越严重，同时对于能延伸至低可能性事件（这类事件当然不常见）领域的先验代表的依赖度也便越高。 世界上不到0.25%的上市公司代表着大约一半的市场资本化，世界上极少部分的小说占据了约半数的小说销量，不到0.1%的药品为制药工业赢得了超过一半的利润——同样，不到0.1%的风险事件会引发至少一半的破坏与损失。 在极端情况下，可以预测失败但无法预测失败造成的损失的规模，也许是指数级的误差。所以小心驶得万年船。 考证的担子要落在破坏复杂体系的人身上，而不是保持现状的人身上。 保持一份专业的同时也得学会涉猎其它领域，没有谁规定医生是不能当银行家的。 避免低可能性盈利的预测——尽管对一般盈利没有必要。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:11","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["Redis"],"content":"Redis 哨兵高可用","date":"2020-03-03","objectID":"/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8/","tags":["Redis"],"title":"Redis哨兵高可用","uri":"/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8/"},{"categories":["Redis"],"content":"Redis","date":"2020-02-18","objectID":"/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/","tags":["Redis"],"title":"Redis主从架构","uri":"/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["Redis"],"content":"Redis 数据持久化","date":"2020-02-03","objectID":"/redis%E6%8C%81%E4%B9%85%E5%8C%96/","tags":["Redis"],"title":"Redis持久化","uri":"/redis%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["Redis"],"content":"Redis 数据结构","date":"2019-12-25","objectID":"/redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":["Redis"],"title":"Redis的数据结构","uri":"/redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Java学习资料总结","date":"2019-11-23","objectID":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/","tags":["Java"],"title":"Java学习资料总结","uri":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/"},{"categories":["Java"],"content":" 雇佣 Java 程序员的完整指南（英文） Java 程序员招聘非常常见，本文总结了企业对于初级、中级、高级、架构师各个级别的 Java 程序员应该考察哪些方面。 java-design-patterns 一个开源仓库，收集 Java 语言的各种编程模式。 Java 开发者需要知道的20个库（英文） 本文介绍 Java 语言20个常用的库，比如 log4j、JUnit、JSoup 等。 巡云轻论坛系统 Java + MySQL 开发的一个论坛程序，自适应手机端和电脑端，界面简洁，功能完整 10本 Java 语言好书 这个书单推荐了10本学习 Java 语言的必读书，前三名是 Effective Java、Clean Code 和 Java Concurrency in Practice。 Java 的类 Java 语言以众多的类著称，但是你知道它一共有多少个 public Class 吗？ 为什么选择 Java 作为后端开发语言？（英文） 本文介绍了 Java 语言用在后端开发的一些优势。 JCSprout 一个收集 Java 核心知识的中文库。 MyPerf4J Java 应用的性能监控工具 Java 语言如何实现线程间通信（英文） 一篇简单的教程，Java 语言如何实现多线程编程。 advanced-java（中文） Java 互联网开发的知识笔记，涉及MQ、ES、Redis等周边工具。 互动式计算机语言学习网站 该网站提供近10种常用语言（C、Python、JS、Java 等等）的实例教程 在线学习java 记忆语法 ","date":"2019-11-23","objectID":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/:0:0","tags":["Java"],"title":"Java学习资料总结","uri":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/"},{"categories":["HTML"],"content":"重新学习HTML","date":"2019-11-05","objectID":"/html/","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"1、简述一下 src 与 href 的区别 href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置； 在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 ","date":"2019-11-05","objectID":"/html/:1:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"2、html 中 title 属性和 alt 属性的区别 ？ 有title,那么无论图片能不能正常显示，鼠标放上去都会出现title。有alt，当图片不能正常加载的时候，会显示alt内容。 \u003cimg src=\"#\" alt=\"alt 信息\" /\u003e 当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。 当图片正常读取，不会出现 alt 信息。 \u003cimg src=\"#\" alt=\"alt 信息\" title=\"title 信息\" /\u003e 当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。 当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。 ","date":"2019-11-05","objectID":"/html/:2:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"3、讲述你对 reflow回流 和 repaint重绘 的理解 原因：浏览器渲染机制 戳戳戳，你真的了解回流和重绘吗? 严重性： 在性能优先的前提下，性能消耗 回流 大于 重绘 体现：repaint 是某个 DOM 元素进行重绘；reflow 是整个页面进行重排，也就是页面所有 DOM 元素渲染。 如何触发： style 变动造成 重绘 和 回流 1、重绘 ： color 的修改，如 color=#ddd text-align 的修改，如 text-align=center a:hover 也会造成重绘 :hover 引起的颜色等不导致页面回流的 style 变动 2、回流： width/height/border/margin/padding 的修改，如 width=778px； 动画，:hover 等伪类引起的元素表现改动，display=none 等造成页面回流； 对可见的DOM元素操作； 插入、删除元素，appendChild 等 DOM 元素操作； font 类 style 的修改； background 的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分 background 的修改只触发 repaint，当然 IE 不用考虑； scroll 页面，这个不可避免； resize 页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize 程序窗口大小的多窗口操作系统。 读取元素的属性：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight……），当你获取布局信息的操作的时候，会强制队列刷新 3、如何避免： 尽可能不要用js来控制DOM来修改style、合并多次对DOM操作（减少for循环） 如果要实现动画，用position：absoulte/fixed 脱离文档流，这样受影响的只有当前元素 避免使用 table 进行布局：table 的每个元素的大小以及内容的改动，都会导致整个 table 进行重新计算，造成大幅度的 repaint 或者 reflow。改用 div 则可以进行针对性的 repaint 和避免不必要的 reflow。 对布局样式属性获取最好将其值缓存起来，避免重复计算 避免在 CSS 中使用运算式：这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的 repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。 牺牲平滑度满足性能：动画精度太强，会造成更多次的 repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。 注意：回流一定会触发重绘，而重绘不一定会回流 ","date":"2019-11-05","objectID":"/html/:3:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"4、HTML5 为什么只需要写 \u003c !DOCTYPE HTML\u003e ？ HTML5 不基于 SGML(标准通用标记语言（以下简称“通用标言”)，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 ","date":"2019-11-05","objectID":"/html/:4:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"5、行内元素有哪些 ？块级元素有哪些 ？ 空(void)元素有那些 ？ CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值。 如 div 的 display 默认值为 “block”，则为“块级”元素； span 默认 display 属性值为 “inline”，是“行内”元素。 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p 常见的空元素： img input link meta br hr ，鲜为人知的是：area base col command embed keygen param source track wbr ","date":"2019-11-05","objectID":"/html/:5:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"6、HTML5 有哪些新特性？如何处理 HTML5 新标签的浏览器兼容问题 ？ 新特性： 1、绘画 canvas; 2、用于媒介回放的 video 和 audio 元素; 3、本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; 4、sessionStorage 的数据在浏览器关闭后自动删除; 5、语意化更好的内容元素，比如 article、footer、header、nav、section; 6、表单控件：calendar、date、time、email、url、search; 7、新的技术：webworker, websocket, Geolocation; 支持 HTML5 新标签： 1、IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 2、然也可以直接使用成熟的框架、比如 script 引入 html5shim; ","date":"2019-11-05","objectID":"/html/:6:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"7、简述一下你对 HTML 语义化的理解 ？ 1、用正确的标签做正确的事情。 2、html 语义化让页面的内容结构化，结构更清晰， 3、搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; ","date":"2019-11-05","objectID":"/html/:7:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"8、请描述一下 cookies，sessionStorage 和 localStorage 的区别 ？ 作用区别： cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。在同源的 http 请求中携带（即使不需要），也会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 ","date":"2019-11-05","objectID":"/html/:8:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"9、iframe 内嵌框架有那些缺点 ？ 内联框架 iframe 一般用来包含别的页面，例如 我们可以在我们自己的网站页面加载别人网站的内容，为了更好的效果，可能需要使 iframe 透明效果； iframe 会阻塞主页面的 onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。 ","date":"2019-11-05","objectID":"/html/:9:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"10、Label 的作用是什么？是怎么用的 ？ label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 和 for 功能使用 \u003clabel for=\"Name\"\u003eNumber:\u003c/label\u003e \u003cinput type=\"“text“\" name=\"Name\" id=\"Name\" /\u003e \u003clabel\u003eDate:\u003cinput type=\"text\" name=\"B\"/\u003e\u003c/label\u003e ","date":"2019-11-05","objectID":"/html/:10:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"11、如何实现浏览器内多个标签页之间的通信 ? WebSocket、SharedWorker； 也可以调用 localstorge、cookies 等本地存储方式； localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信； ","date":"2019-11-05","objectID":"/html/:11:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"12、网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序； 可以防止恶意、暴力破解密码、刷票、论坛灌水； ","date":"2019-11-05","objectID":"/html/:12:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"13、前端页面有哪三层构成，分别是什么？作用是什么？ 网页分成三个层次，即：结构层、表示层、行为层。 网页的结构层（structurallayer）由 HTML 或 XHTML 之类的标记语言负责创建。 网页的表示层（presentationlayer）由 CSS 负责创建。CSS 对“如何显示有关内容”的问题做出了回答。 网页的行为层（behaviorlayer）由Javascript负责回答 “内容应该如何对事件做出反应” 这一问题。 ","date":"2019-11-05","objectID":"/html/:13:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"14、盒子模型的理解 ? CSS 盒子模型具有内容 (content)、填充 (padding)、边框 (border)、边界 (margin)这些属性。我们所说的 width，height 指的是内容 (content) 的宽高。 一个盒子模型的中： 宽度 = width+ padding(宽) + border(宽)。 高度 = height + padding(高) + border(高)。 ","date":"2019-11-05","objectID":"/html/:14:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"15、box-sizing 常用的属性有哪些 ？分别有什么作用 ？ 常用的属性：box-sizing: content-box border-box inherit; 作用： content-box(默认)： 宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。即宽度和高度会变化，内容使用在宽高内部。 border-box： 元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。即宽度高度不会变，内容可能超出宽高。 ","date":"2019-11-05","objectID":"/html/:15:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"16、页面导入样式时，使用 link 和 @import 有什么区别 ？ link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS @import 是 CSS 提供的，只能用于加载 CSS import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题 ","date":"2019-11-05","objectID":"/html/:16:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"17、常见兼容性问题？ 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin: 0; padding: 0;} 来统一。 IE 下 event 对象有 event.x，event.y 属性，而 Firefox 下没有。Firefox 下有 event.pageX，event.PageY 属性，而 IE 下没有。 解决办法：var mx = event.x?event.x:event.pageX; Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. ","date":"2019-11-05","objectID":"/html/:17:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"18、position 、float 和 display 的取值 position 属性取值：static(默认)、relative、absolute、fixed、inherit、sticky float：left (或 right)，向左（或右）浮动 display 属性取值：none、inline、inline-block、block、table 相关属性值、inherit ","date":"2019-11-05","objectID":"/html/:18:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"19、以 CSS3 标准定义一个 webkit 内核浏览器识别的圆角（尺寸随意） -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; ","date":"2019-11-05","objectID":"/html/:19:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"20、优先级算法如何计算？ !important \u003e 写在内联优先级高 \u003eid \u003e class \u003etag 载入样式以最后载入的定位为准 ","date":"2019-11-05","objectID":"/html/:20:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"21、CSS3 新增伪类举例 :after 选择器在被选元素的内容后面插入内容 :before 选择器在被选元素的内容前面插入内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n :nth-child(odd) 奇数 :nth-child(even) 偶数 :nth-child(3n+1) ","date":"2019-11-05","objectID":"/html/:21:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"22、什么是响应式设计 ？响应式设计的基本原理是什么 ？ 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本 基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有 meta 声明的 viewport rem、vw/vh、插件postcss-px-to-viewport 戳戳戳，媒体查询使用方式 \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e width=device-width: 让当前viewport宽度等于设备的宽度 user-scalable=no: 禁止用户缩放 initial-scale=1.0: 设置页面的初始缩放值为不缩放 maximum-scale=1.0: 允许用户的最大缩放值为1.0 minimum-scale=1.0: 允许用户的最小缩放值为1.0 ","date":"2019-11-05","objectID":"/html/:22:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"23、::before 和 :after 中双冒号和单冒号有什么区别 ？解释一下这 2 个伪元素的作用 单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素 ::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中 ","date":"2019-11-05","objectID":"/html/:23:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"23、style 标签写在 body 后与 body 前有什么区别？ 页面加载自上而下，当然是先加载样式。 写在 body 标签后，由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题） ","date":"2019-11-05","objectID":"/html/:24:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"24、rem、em、px、vh 与 vw 的区别 ？ px：表示像素，相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。 em：一个字的高度，是相对长度单位 //1em == 自己font-size的值 rem：root em // 根元素html的font-size vh：viewport height 视口高度=100vh vw：viewport width 视口宽度=100vw ","date":"2019-11-05","objectID":"/html/:25:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["WebRTC"],"content":"WebRTC涉及名词和学习资料","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"UDP和TCP TCP和UDP的区别 TCP和UDP的最完整的区别 TCP/UDP协议详解 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:1","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"RTP/RTCP RTP/RTCP协议解析 RTP/RTSP/RTCP有什么区别？ 实时传输协议 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:2","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"SRTP/SRTCP 维基百科：安全实时传输协议 安全实时传输协议（Secure Real-time Transport Protocol或SRTP）是在实时传输协议（Real-time Transport Protocol或RTP）基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由David Oran（思科）和Rolf Blom（爱立信）开发的，并最早由IETF于2004年3月作为RFC 3711发布。 由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol或RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP或SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。 在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:3","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"DTLS DTLS的主要用途，就是让通信双方协商密钥，用来对数据进行加解密。 通信双方：通过DTLS握手，协商生成一对密钥； 发送方：对数据进行加密； 发送方：通过UDP传输加密数据； 接收方：对加密数据进行解密； ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:4","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"STUN/TURN NAT打洞 NAT穿越 P2P穿越 ICE P2P技术之STUN、TURN、ICE详解 WebRTC直播技术(二)-ICE/STUN/TURN WebRTC之STUN、TURN和ICE研究 P2P通信标准协议(一)之STUN ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:5","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"真实的SDP片段 // v 开始会话级描述 v=0 o=- 7017624586836067756 2 IN IP4 127.0.0.1 s=- t=0 0 // m 开始媒体级描述 //下面 m= 开头的两行，是两个媒体流：一个音频，一个视频。 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126 ... m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116 上面的SDP片段所示，该 SDP 中描述了一路音频流，即m=audio，该音频支持的 Payload ( 即数据负载 ) 类型包括 111、103、104等等。 在该 SDP 片段中又进一步对 111、103、104 等 Payload 类型做了更详细的描述，如 a=rtpmap:111 opus/48000/2 表示 Payload 类型为 111 的数据是 OPUS 编码的音频数据，并且它的采样率是 48000，使用双声道。以此类推，你也就可以知道 a=rtpmap:104 ISAC/32000 的含义是音频数据使用 ISAC 编码，采样频率是 32000，使用单声道。 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:6","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"webRTC脑图 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"参考资料 WebRTC：数据传输相关协议简介 WebRTC：一个视频聊天的简单例子 免费开源项目starRTC WebRTC学习 WebRTC实验 官方文档 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"WebRTC核心API","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"WebRTC核心API可以分为两类 Streams Streams API允许JavaScript以编程的方式访问通过网络接收的数据流，并根据开发人员的需要处理它们。 MediaDevices MediaDevices 接口提供访问连接媒体输入的设备，如照相机和麦克风，以及屏幕共享等。 enumerateDevices() 可用的媒体输入和输出设备的列表，例如麦克风，摄像头，耳机设备。切换设备时用 getDisplayMedia() 选择和授权捕获用户选择的屏幕区域以及一个可选的音频轨道 getStupportedConstraints() 监视客户端所支持的约束属性，比如视频高宽，码率等 getUserMedia() 提示用户授权使用媒体输入，媒体输入会产生MediaStream，里面包含了请求的媒体类型的音视频或其他轨道 如果网页使用了getUserMedia方法，浏览器就会询问用户，是否同意浏览器调用麦克风或摄像头。如果用户同意，就调用回调函数onSuccess；如果用户拒绝，就调用回调函数onError 成功回调函数 获取多媒体设备成功时调用。onSuccess回调函数的参数是一个数据流对象stream。stream.getAudioTracks方法和stream.getVideoTracks方法，分别返回一个数组，其成员是数据流包含的音轨和视轨（track）。 使用的声音源和摄影头的数量，决定音轨和视轨的数量。比如，如果只使用一个摄像头获取视频，且不获取音频，那么视轨的数量为1，音轨的数量为0。每个音轨和视轨，有一个kind属性，表示种类（video或者audio），和一个label属性（比如FaceTime HD Camera (Built-in)）。 失败回调函数 获取多媒体失败时调用。Error对象的code属性有说明错误的类型： PERMISSION_DENIED：用户拒绝提供信息。 NOT_SUPPORTED_ERROR：浏览器不支持硬件设备。 MANDATORY_UNSATISFIED_ERROR：无法发现指定的硬件设备。 //新版本Chrome中getUserMedia接口在http下不再支持。要使用HTTPS协议 navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; //兼容 navigator.getUserMedia({ audio: true, video: { width: 1280, height: 720 } }, (success)=\u003e{ console.log('success'+ success) let video = document.querySelector(\"video\"); // video.src = window.URL.createObjectURL(stream);这种写法已被移除 video.srcObject = stream; }, (error)=\u003e{ console.log('err'+ error) }); // 如果存在回声，应该在video或者audio节点处添加muted，进行简单的回声消噪 demo RTCPeerConnection RTCPeerConnection 接口代表一个由本地计算机到远端的WebRTC连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。 不同客户端之间的音频/视频传递，是不用通过服务器的。但是，两个客户端之间建立联系，需要通过服务器。服务器主要转递两种数据。 通信内容的元数据：打开/关闭对话（session）的命令、媒体文件的元数据（编码格式、媒体类型和带宽）等。 网络通信的元数据：IP地址、NAT网络地址翻译和防火墙等。 var signalingChannel = createSignalingChannel(); var pc; var configuration = ...; // run start(true) to initiate a call function start(isCaller) { pc = new RTCPeerConnection(configuration); // send any ice candidates to the other peer pc.onicecandidate = function (evt) { signalingChannel.send(JSON.stringify({ \"candidate\": evt.candidate })); }; // once remote stream arrives, show it in the remote video element pc.onaddstream = function (evt) { remoteView.src = URL.createObjectURL(evt.stream); }; // get the local stream, show it in the local video element and send it navigator.getUserMedia({ \"audio\": true, \"video\": true }, function (stream) { selfView.src = URL.createObjectURL(stream); pc.addStream(stream); if (isCaller) pc.createOffer(gotDescription); else pc.createAnswer(pc.remoteDescription, gotDescription); function gotDescription(desc) { pc.setLocalDescription(desc); signalingChannel.send(JSON.stringify({ \"sdp\": desc })); } }); } signalingChannel.onmessage = function (evt) { if (!pc) start(false); var signal = JSON.parse(evt.data); if (signal.sdp) pc.setRemoteDescription(new RTCSessionDescription(signal.sdp)); else pc.addIceCandidate(new RTCIceCandidate(signal.candidate)); }; RTCPeerConnection带有浏览器前缀，Chrome浏览器中为webkitRTCPeerConnection，Firefox浏览器中为mozRTCPeerConnection。Google维护一个函数库adapter.js，用来抽象掉浏览器之间的差异。 ","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/:0:0","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"参考链接 MDN Streams API MDN MediaDevices MDN RTCPeerConnection WebRTC 教程 WebRTC – JavaScript 标准参考教程 ","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/:0:1","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"WebRTC简介","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["WebRTC"],"content":"MDN上对WebRTC是这样说的： WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。 WebRTC的前世今生 on2：主流的桌面及移动应用和设备 提供高质量视频压缩技术 主要视频编解码格式包括 VP3-VP8，被谷歌收购，集成到WebRTC中 Global IP Solutions (GIPS) 的前身为Global IP Sound (GIPS)，专为数据包网络的实时通信应用市场，开发行业领先的嵌入式媒体处理解决方案。 Google 11年收购了它们，开源了 WebRTC项目，推进标准化 2017年11月W3C发布了WebTTC 1.0 webRTC体系架构 这张图来源于webRTC入门，应该每个人最开始接触webRTC时都会知道架构图，它描述了RTCPeerConnection的作用。 图中可以看出一共三个不同的层： web开发人员的API：包括RTCPeerConnection、RTCDataChannel和 MediaStrean对象 浏览器厂商的API 供浏览器厂商以hook方式复写的API 传输组件允许在不同类型的网络中建立连接，而语音视频引擎是负责将音频视频流从声卡和摄像机传输到网络的框架。对于web开发人员来说,最重要的部分是WebRTC API。 ","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/:0:0","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["WebRTC"],"content":"参考链接 Getting Started with WebRTC - HTML5 Rocks ","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/:0:1","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["HTML"],"content":"前端性能优化","date":"2019-07-23","objectID":"/web-performance-optimization/","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"网络层面 请求过程的优化 HTTP请求优化 Gzip压缩 //request headers 中加上这么一句 accept-encoding:gzip 图片优化 WebP是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。 减少网络请求 浏览器缓存 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:1","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"渲染层面 服务端渲染 服务端渲染通常是为了SEO，但是服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。 浏览器的渲染机制 CSS性能方案 JS性能方案 DOM优化 原理和思路 异步循环与异步更新 回流与重绘 首屏渲染 懒加载 ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:2","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"性能监控 可视化工具 Peformance Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。 LightHouse Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。 W3C性能API W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。 访问 performance 对象performance 是一个全局对象。 window.performance ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:3","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["读书"],"content":"这是一本书，《恭喜你，当上主管了》","date":"2019-07-21","objectID":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/","tags":["读书"],"title":"《恭喜你，当上主管了》","uri":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/"},{"categories":["读书"],"content":" 主管推荐了一本书给我，记录下读书笔记。 管理不是靠努力及运气 了解自己和下属 管理前必须先学习“人际沟通”素养和技巧，以及“情绪压力”的处理方式。 “管理机制”、“执行能力\"的知识. 正视自己的工作价值观，面对自我成长的机会。 在职场身份发生改变时，心态和观念也要转变： 从员工变成主管时，最重要的是心态和观念上的转变。 当上主管，在角色上就要将“个人需求”，转化为“员工需求”。 你要带领下属完成部门的工作目标，也就是你要协助部门每一个人完成他们的工作目标。 先管理【人】，在操作【事】。 【事】的管理只是工作目标中的一环； 【人】才是管理的关键 建立良好人际关系互动 真： 真诚的态度，就是能将自己的情感、需求和理念，忠实且适当表达出来，同时也能用于承认自己的错误。 爱：无私的关爱，就是能自由地去接纳并尊重别人，不强迫将自己的价值观加诸于别人身上。 同理心的感受，就是能真正以他人的立场去了解他人，并一定表示同意，而是一种理解别人的能力。 基本上，会影响组织内人际关系的因素，不外乎：沟通渠道和环境、谣言批评和攻击、立场不同、派系斗争、业绩竞争、升迁竞争或是客户间的利害关系。 沟通的三个准则： 要是双向的 不要先入为主 要先处理情绪再处理问题 面对情绪压力 当情绪来时，你可能无法掌握，甚至连自己都难以察觉，继而做出失态的行动，或错误的决策，导致事后后悔。 情绪处理的最好方法是，通过平时的自我管理训练，做一名好的情绪管理者。 当事情很多时，如果没有良好的掌控力和应变力，很容易就会陷入压力的困境。 掌控力：对工作的了解能力和对情绪的处理能力。 应变力：遇到突发事件的变通弹性能力和协调能力。 职场的情绪压力一般来源于： 工作本身 工作负荷过重、危险性高、时间太长或是能力极限 组织发展 指在组织中，受到过多限制、决策独断、缺乏沟通、晋升太快或太慢、无法获得满足感或肯定 人际关系 指与上司、同事或部署的关系不良，或发生冲突等。 个人因素 指个人的性格特质、兴趣、家庭责任及生活危机。 如何处理情绪： 面对它，接受它，处理它，放下它 —圣严法师 做对问题解决。 任何问题发生后，一定要去了解问题的所在，从中学习，找出真正的问题。失败并不可怕，可怕的是我们无法从中吸取教训，学习到宝贵的经验 停看听 停：先冷静面对事情，了解事情的来龙去脉 看： 看看事情的资料和数据，理清问题所在 听： 听听别人的意见，不要自己立即下判断。不要自己闭门造车，或者匆匆忙忙立即下判断。 遇到突发问题，事后要做复盘，那些是可以改善的，能否有做得更好的方式。 ","date":"2019-07-21","objectID":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/:0:0","tags":["读书"],"title":"《恭喜你，当上主管了》","uri":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/"},{"categories":["其他"],"content":"浏览器搜索技巧","date":"2019-06-17","objectID":"/search-skill/","tags":["其他"],"title":"搜索技巧","uri":"/search-skill/"},{"categories":["其他"],"content":" 「+」空格就是加号，搜索 purpose of education 那结果中会有，purpose 和 education 不一定有purpose of education，一些常用的词汇被省略，比如 of the a in and that 等，如果需要这个词出现就用 「+」，my mother +where 「\"\"」完全匹配，“i love fangfang” 搜索就会完全匹配这句话 「-」减号，苹果 -红色，就会搜出不带 “红色” 的苹果 「*」通配符 「~」~单词，自动把这个单词替换成相关的词汇 「OR」或，苹果OR香蕉，要大写，如果 or 则会被忽略 搜索内容后面加 site:zhihu.com，就会在这个域名内搜索 举例： web ~教程 -csdn -cnblogs 或 csdn -site:csdn.net 大家可以去试试 ","date":"2019-06-17","objectID":"/search-skill/:0:0","tags":["其他"],"title":"搜索技巧","uri":"/search-skill/"},{"categories":["Java"],"content":"Java 多线程","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java"],"content":"进程和线程 线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 一个进程可以有很多线程，每条线程并行执行不同的任务。 Java线程 最简单的情况是，Thread/Runnable的run()方法运行完毕，自行终止。 Java中创建线程的方式有两种，不管使用继承Thread的方式还是实现Runnable接口的方式，都需要重写run方法。 //继承Thread类 1、 定义继承Thread; 2、复写Thread类中的run方法;（目的：将自定义代码存储在run方法中，让线程运行（同时运行，抢夺资源）） 3、调用线程的start方法；（目的：启动线程，调用run方法） //实现Runnable接口 1、定义类实现Runnable接口； 2、覆盖Runnable接口中的run方法； 3、通过Thread类建立线程对象； 4、将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法； 5、调用Thread类的start方法，开启线程并调节Runnable接口子类的run方法； //区别： 继承只能继承一个，具有局限性。 继承Thread: 线程代码存放在子类run。 实现runnable: 线程代码存放在接口的子类run。 对于更复杂的情况，比如有循环，则可以增加终止标记变量和任务终止的检查点。 最常见的情况，也是为了解决阻塞不能执行检查点的问题，用中断来结束线程，但中断只是请求，并不能完全保证线程被终止，需要执行线程协同处理。 IO阻塞和等锁情况下需要通过特殊方式进行处理。 使用Future类的cancel()方法调用。 调用线程池执行器的shutdown()和shutdownNow()方法。 守护线程会在非守护线程都结束时自动终止。 Thread有stop()方法，但已不推荐使用。 Java中进程与线程的关系： 运行一个程序会产生一个进程，进程至少包含一个线程。 每个进程对应一个JVM实例，多个线程共享JVM中的堆。 Java采用单线程编程模型，程序会自动创建主线程。 主线程可以创建子线程，原则上要后于子线程完成执行。 多线程 即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。 ","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java"],"content":"为什么需要多线程 现代CPU都是多核的 Java执行模型是同步/阻塞(block)的 默认情况下只有一个进程 处理问题非常自然 但是具有严重的性能问题 开启一个新的线程 Thread Java中只有这么一种东西代表线程 start方法才能并发执行 每多开一个线程，就多一个执行流 方法栈（局部变量）是线程私有的 静态方法/类变量是被所有线程共享的 多线程带来的性能提升 对于IO密集型应用及其有用 网络IO （通常包括数据库） 文件IO 对于CUP密集型应用稍有折扣 性能提升的上线在哪里？ 单核CPU 100% 多核CUP N * 100% 昂贵的线程 能不能使用线程达到无穷无尽的性能提升? 线程的昂贵性在于 CPU切换上下文很慢 线程需要占用内存等系统资源 如果应用一天才几个用户 new Thread().start() 如果应用负载很高 使用线程池： JUC包 线程安全 原子性 共享变量 默认的实现几乎都不是线程安全的 线程不安全的表现 数据错误 i++ if-then-do 死锁 线程安全 实现线程安全的基本手段 不可变类 Integer/String synchronized 同步块 JUC包 AtomicInteger ConcurrentHashMap 任何使用HashMap有线程安全问题的地方，都无脑使用ConcurrentHashMap替换即可 ReentrantLock … 线程池与Callable/Future 什么是线程池 线程池是昂贵的（Java线程模型的缺陷） 线程池是预先定义好的若干个线程 Java中的线程池 Callable/Future 类比Runnable，Callable可以返回值，抛出异常 Future代表一个“未来才会返回的结果” 多线程的经典问题 生产者/消费者模型 解决方法： wait/notify/notifyAll Lock/Condition BlockingQueue ","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:1","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["webpack"],"content":"提升 webpack 的构建速度","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"我们来聊聊如何提升 webpack 的构建速度，也许某一天你负责的项目也会到了需要优化 webpack 构建性能的时候。 我们的前端项目随着时间推移和业务发展，页面可能会越来越多，或者功能和业务代码会越来越多，又或者依赖的外部类库会越来越多，这个时候原本不足为道的 webpack 构建时间消耗就会慢慢地进入我们的视野。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:0:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"让 webpack 少干点活 提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"减少 resolve 的解析 在前边第三小节我们详细介绍了 webpack 的 resolve 配置，如果我们可以精简 resolve 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些，下面举个例子，介绍如何在 resolve 这一块做优化： resolve: { modules: [ path.resolve(__dirname, 'node_modules'), // 使用绝对路径指定 node_modules，不做过多查询 ], // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作 // 其他文件可以在编码时指定后缀，如 import('./index.scss') extensions: [\".js\"], // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度 mainFiles: ['index'], }, 上述是可以从配置 resolve 下手提升 webpack 构建速度的配置例子。 我们在编码时，如果是使用我们自己本地的代码模块，尽可能编写完整的路径，避免使用目录名，如：import './lib/slider/index.js'，这样的代码既清晰易懂，webpack 也不用去多次查询来确定使用哪个文件，一步到位。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:1","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"把 loader 应用的文件范围缩小 我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了： rules: [ { test: /\\.jsx?/, include: [ path.resolve(__dirname, 'src'), // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理 // 通常我们需要 loader 处理的文件都是存放在 src 目录 ], use: 'babel-loader', }, // ... ], 如上边这个例子，如果没有配置 include，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:2","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"减少 plugin 的消耗 webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的话，适当地移除掉一些没有必要的 plugin。 这里再提一下 webpack 4.x 的 mode，区分 mode 会让 webpack 的构建更加有针对性，更加高效。例如当 mode 为 development 时，webpack 会避免使用一些提高应用代码加载性能的配置项，如 UglifyJsPlugin，ExtractTextPlugin 等，这样可以更快地启动开发环境的服务，而当 mode 为 production 时，webpack 会避免使用一些便于 debug 的配置，来提升构建时的速度，例如极其消耗性能的 Source Maps 支持。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:3","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"换种方式处理图片 我们在前边的小节提到图片可以使用 webpack 的 image-webpack-loader 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。 这里介绍一种解决思路，我们可以直接使用 imagemin 来做图片压缩，编写简单的命令即可。然后使用 pre-commit 这个类库来配置对应的命令，使其在 git commit 的时候触发，并且将要提交的文件替换为压缩后的文件。 这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:4","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"使用 DLLPlugin DLLPlugin 是 webpack 官方提供的一个插件，也是用来分离代码的，和 optimization.splitChunks（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 optimization.splitChunks 即可。 我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 webpack.dll.config.js： module.exports = { name: 'vendor', entry: ['lodash'], // 这个例子我们打包 lodash 作为公共类库 output: { path: path.resolve(__dirname, \"dist\"), filename: \"vendor.js\", library: \"vendor_[hash]\" // 打包后对外暴露的类库名称 }, plugins: [ new webpack.DllPlugin({ name: 'vendor_[hash]', path: path.resolve(__dirname, \"dist/manifest.json\"), // 使用 DLLPlugin 在打包的时候生成一个 manifest 文件 }) ], } 然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 webpack.DllReferencePlugin 配置： module.exports = { plugins: [ new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, 'dist/manifest.json'), // 指定需要用到的 manifest 文件， // webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取 }), ], } 在构建的时候，我们需要优先使用 webpack.dll.config.js 来打包，如 webpack -c webpack.dll.config.js --mode production，构建后生成公共代码模块的文件 vendor.js 和 manifest.json，然后再进行应用代码的构建。 你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 vendor.js 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如： \u003cscript src=\"vendor.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e 作用是不是和 optimization.splitChunks 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 webpack.dll.config.js 这一部分的构建，沿用原本的构建结果即可，所以相比 optimization.splitChunks，使用 DLLPlugin 时，构建速度是会有显著提高的。 但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 webpack.dll.config.js 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 optimization.splitChunks 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。 还有一点需要注意的是，html-webpack-plugin 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 add-asset-html-webpack-plugin，关于这一个的使用就不讲解了，详细参考官方的说明文档：使用 add-asset-html-webpack-plugin。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:2:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"webpack 4.x 的构建性能 从官方发布的 webpack 4.0 更新日志来看，webpack 4.0 版本做了很多关于提升构建性能的工作，重要的改进有这么几个： AST 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 PR。 使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。 Node 语言层面的优化，如用 for of 替换 forEach，用 Map 和 Set 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 PRs 寻找更多的内容。 默认开启 uglifyjs-webpack-plugin 的 cache 和 parallel，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。 除此之外，还有比较琐碎的一些内容，可以查阅：webpack release 4.0，留意 performance 关键词。 很显然，webpack 的开发者们越来越关心 webpack 构建性能的问题，有一个关于 webpack 4.x 和 3.x 构建性能的简单对比： 6 entries, dev mode, source maps off, using a bunch of loaders and plugins. dat speed ⚡️ 从这个对比的例子上看，4.x 的构建性能对比 3.x 是有很显著的提高，而 webpack 官方后续计划加入多核运算，持久化缓存等特性来进一步提升性能（可能要等到 5.x 版本了），所以，及时更新 webpack 版本，也是提升构建性能的一个有效方式。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:3:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"换个角度 webpack 的构建性能优化是比较琐碎的工作，当我们需要去考虑 webpack 的构建性能问题时，往往面对的是项目过大，涉及的代码模块过多的情况。在这种场景下你单独做某一个点的优化其实很难看出效果，你可能需要从我们上述提到的多个方面入手，逐一处理，验证，有些时候你甚至会觉得吃力不讨好，投入产出比太低了，这个时候我们可以考虑换一个角度来思考我们遇到的问题。 例如，拆分项目的代码，根据一定的粒度，把不同的业务代码拆分到不同的代码库去维护和管理，这样子单一业务下的代码变更就无须整个项目跟着去做构建，这样也是解决因项目过大导致的构建速度慢的一种思路，并且如果处理妥当，从工程角度上可能会给你带来其他的一些好处，例如发布异常时的局部代码回滚相对方便等等。 这可能有点跑题，但是不得不说，webpack 的确是一个好工具，但总归多多少少会有一些局限性，再怎么优化，不可能总能达到理想的效果，因为它确确实实完成那些构建任务就是需要这么一些时间。作为开发者，面对项目中各种各样的情况要随机应变，灵活处理，不能被好工具捆绑了思维模式，很多问题你不要过于依赖于 webpack，换个角度，可能可以找到更好的处理方式。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:4:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"总结 减少 resolve 的解析 减少 plugin 的消耗 换种方式处理图片 使用 DLLPlugin 积极更新 webpack 版本 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:5:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"参考 掘金小册 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:6:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["Web"],"content":"Docker 部署简单的 Web 服务","date":"2019-04-20","objectID":"/docker-deploy-web/","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"Docker 部署 Web ","date":"2019-04-20","objectID":"/docker-deploy-web/:0:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"目录结构 首先，根据以下目录建立对应的文件。 . ├ test.js ├ DockerFile ├ package.json test.js 文件内容如下： const Koa = require('koa'); const app = new Koa(); app.use(function(ctx) { ctx.body = 'hello docker'; }); app.listen(8998); DockerFile 文件内容如下： FROMnodeCOPY . /appWORKDIR/appRUN [\"npm\", \"install\"]EXPOSE3456CMD node test.js ","date":"2019-04-20","objectID":"/docker-deploy-web/:1:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"生成镜像 执行命令生成自定义镜像。 docker image build . -t mytest1 ","date":"2019-04-20","objectID":"/docker-deploy-web/:2:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"运行容器 将刚刚创建的镜像，通过容器跑起来。 docker container run -p 8000:8998 mytest1 执行完毕之后，在浏览器中直接访问 localhost:8000 就可以看到 hello docker 了。 ","date":"2019-04-20","objectID":"/docker-deploy-web/:3:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Docker"],"content":"初步学习Docker","date":"2019-03-23","objectID":"/docker-study/","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"什么是Docker Docker是一个开源的应用容器引擎，提供了一种在安全、可重复的环境中自动部署软件的方式，允许开发者将他们的应用和依赖包打包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 ","date":"2019-03-23","objectID":"/docker-study/:0:1","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"Docker基本概念 Docker 包括三个基本概念 镜像（Image） 一个特殊的文件系统 容器（Container） 镜像运行时的实体 仓库（Repository） 集中存放镜像文件的地方 Docker 安装 //deepin 系统 sudo apt-get install docker-ce docker 一些命令 Hello World docker run hello-world 查看docker信息 docker info 启动docker systemctl start docker 重启docker sudo service docker restart 查看容器 docker ps # 查看运行中的容器 docker ps -a # 查看所有容器 列出镜像 docker image ls 查看所有已经创建的包括终止状态的容器 docker container ls -a 镜像体积 docker system df 终止容器 docker container stop 删除容器 docker container rm //删除一个处于终止状态的容器 清理所有处于终止状态的容器 docker container prune 容器操作 # 停止一个容器 docker stop $JOB # 启动一个已经创建的容器 docker start $JOB # 重启一个容器 docker restart $JOB # 停止一个容器 docker kill $JOB # 删除一个容器 docker stop $JOB # 必须先停止 docker rm $JOB 更换国内的 docker 加速器 编辑 /etc/docker/daemon.json 文件，并输入 docker-cn 镜像源地址 { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } 重启docker服务 sudo service docker restart ","date":"2019-03-23","objectID":"/docker-study/:0:2","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"学习资料 Docker — 从入门到实践 Docker基础 从 0 开始了解 Docker ","date":"2019-03-23","objectID":"/docker-study/:1:0","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["工具"],"content":"这是描述","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"1、图片背景 https://www.desktoppr.co/ https://alpha.wallhaven.cc/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:1:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"2、图片压缩（可批量） https://tinypng.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:2:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"3、CSS动画效果 http://animista.net/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:3:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"4、文件格式转换 https://smallpdf.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:4:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"5、字体大小转换 http://pxtoem.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:5:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"6、UI设计 http://www.uiimg.com/Material https://dribbble.com/ 交互设计:可以用 Axure RP、墨刀、Sketch.app 视觉设计：可以用 Photoshop、Fireworks、Sketch.app ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:6:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"7、图标 http://www.iconfont.cn/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:7:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"8、图床 https://sm.ms/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:8:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"9、cdn(库) https://cdnjs.com/ https://www.bootcdn.cn/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:9:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"10、鼠标样式大全 http://css-cursor.techstream.org/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:10:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"11、CSS渐变代码生成器 http://www.colorzilla.com/gradient-editor/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:11:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"12、JSON格式化工具 http://www.bejson.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:12:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["Java"],"content":"Java程序运行流程","date":"2018-09-19","objectID":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/","tags":["Java"],"title":"Java程序运行流程","uri":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["Java"],"content":"java 如何加载的呢 对于Java来说，要执行一个类的main方法，需要先加载它。Java虚拟机规范规定，在加载之后，就要执行方法（java代码的编译过程会把所有的静态初始化块收集到一起在字节码里创建一个方法），所以这一点实际上是类加载的规定。main方法是一个静态方法，所以没有「类的 成员初始化 和 初始化块」发生，除非你接下来使用了new clinit are the static initialization blocks for the class, and static field initialization. 然后再 初始化 类中定义的方法，再执行 main()，最后才是在 heap 里分配一块内存来初始化一个对象（构造函数）—— 执行main的时候没有类的实例产生，所以没有heap内存分配和初始化方法调用发生 java 一个文件就是一个 class，jvm 在解析文件的时候，class 是存在哪里？ 准确的说: Java的一个文件可能编译出来多个class，不过一般而言可以理解成java文件和class文件是一一对应的。class是在heap的一个特殊区域，Java8之前叫“永久代” PermGen，Java8之后叫“元空间” Metaspace，可以理解成专门存放class的地方 「类」 和 「方法」 在内存中初始化和调用？ jvm 是怎么解析一个文件的，程序执行的顺序和在内存分布的情况等 —— 这其实涉及到类加载了, 请去看:《深入了解Java虚拟机》的第七章。 深入理解Java虚拟机.pdf 最最简单的理解是： 当一个类被加载的时候，它自己的空间在堆中被分配（包括static成员，所有的方法字节码包括方法）。随后方法被调用，所有的静态成员得到初始化。这是类加载后立刻发生的事情，发生在main之前。 class文件是一个高度结构化的数据，可以想像成一个JSON文件，只不过人类不可读罢了。JVM读取其中的所有信息，把它们存储在MetaSpace里（“类自己占用的空间”） 当一个方法被调用的时候，JVM在当前线程的方法栈中开辟一个新的栈帧，栈帧的大小由方法的字节码所指定 然后JVM就按照方法字节码指定的指令进行操作 试一试： javap -v -private XXXX.class，它会告诉你类文件的结构。想用图形界面的话，这哥们写了个很有用的工具：[https://github.com/zxh0/classpy]( ","date":"2018-09-19","objectID":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","tags":["Java"],"title":"Java程序运行流程","uri":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["Java"],"content":"Java包管理","date":"2018-09-09","objectID":"/java%E5%8C%85%E7%AE%A1%E7%90%86/","tags":["Java"],"title":"Java包管理","uri":"/java%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["Java"],"content":"什么是包 Class（类）是 Java 中的一等公民，所有的 Java 代码，都要写在类里面 在命名规则下，你可以给类起任何名字。当你使用别人的类时，首先知道的是类名，然后再了解如何使用这个类。 随着人们编写的 Java 类越来越多，就会有个问题：如果出现了名字相同的类怎么办？两个名字相同的 User 类，其内涵是否也一样呢？如果不一样，要如何区分它们呢？ Package （包）就是用来解决这个问题的。通过将同名的类放到不同的包里面，我们就可以： 对同名的类进行区分； 精确地指明我们需要其中的哪一个； 让同名的类在一个程序当中共存。 JVM的工作被设计地相当简单： 执行一个类的字节码 假如这个过程中碰到了新的类，加载它 那么，去哪里加载这些类呢？ 类路路径（Classpath） //可以包含多个可供选择的查询路径。每个路径都用分号隔开 -classpath /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar 类的全限定类名（目录层级）唯一确定了一个类 包就是把许多类放在一起的压缩包! 传递性依赖 你依赖的类还依赖了别的类，JVM只认类的说明书（字节码），你要使用一个库，你就得想办法把这份说明书以及它引用的说明书（传递性依赖）找到，然后给JVM。 看上去不是非常困难是不是？想象一下你的程序运行需要一万份说明书吧（传递性依赖的传递性依赖的传递性依赖） Classpath hell 全限定类名是类的唯一标识 当多个同名类同时出现在Classpath中，就是噩梦的开始 什么是包管理 你要使用一些第三方类，总要告诉JVM从哪里找 包管理的本质就是告诉JVM如何找到所需的第三方类库以及成功地解决其中的冲突问题! 包管理发展历程 手动写命令进行编译运行 Apache Ant 手动下载jar包，放在一个目录中 写XML配置，指定编译的源代码目录、依赖的jar包、输出目录等 缺点 每个人都要自己造一套轮子 依赖的第三方类库都需要手动下载，费时费力 假如你的应用依赖了了一万个第三方的类库呢？ 没有解决Classpath地狱的问题 Maven Convention over configuration 约定优于配置 必须强调，Maven远远不止是包管理工具 Maven的中央仓库 按照一定的约定存储包 Maven的本地仓库 默认位于~/.m2 下载的第三方包放在这里进行缓存 Maven的包 按照约定为所有的包编号，方便检索 groupId/artifactId/version 传递性依赖的自动管理 原则： 绝对不允许最终的classpath出现同名不不同版本的jar包 依赖冲突的解决：原则：最近的胜出 依赖的scope 当你看到如下的异常的时候 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError ","date":"2018-09-09","objectID":"/java%E5%8C%85%E7%AE%A1%E7%90%86/:0:0","tags":["Java"],"title":"Java包管理","uri":"/java%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["Java"],"content":"重载（Overload）和重写（Override）的区别","date":"2018-08-19","objectID":"/java-overload/","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"重载(Overload) 前提： 所有的重载函数必须在同一个类中 重载方法的规则： 参数列表：被重载的方法必须改变参数列表。 返回类型：可以改变返回类型。 修饰符：可以改变修饰符。 异常：可以声明新的或者更广泛的异常。 其中： 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 同名不同参数 public class Demo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } ","date":"2018-08-19","objectID":"/java-overload/:1:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"重写（Override） 前提： 继承 重写的规则： 参数列表：必须与被重写方法的参数列表完全匹配。 返回类型：必须与超类中被重写的方法中声明的返回类型或子类型完全相同 访问级别：一定不能比被重写方法强，可以比被重写方法的弱。 非检查异常：重写方法可以抛出任何非检查的异常，无论被重写方法是否声明了该异常。 检查异常：重写方法一定不能抛出新的检查异常，或比被重写方法声明的检查异常更广的检查异常。 不能重写标志为final, static的方法。 其中： 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。 若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 子类重写的函数的访问修饰权限不能低于父类的。 同名同参数 //父类 public class ParentDemo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } //子类 public class childrenDemo extends ParentDemo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } 构造器constructor是否可以被重写？ 父类的私有方法不能被继承，构造器是不能被继承的，所以就不能被重写。在同一个类中，构造器是可以被重载的 ","date":"2018-08-19","objectID":"/java-overload/:2:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"总结 重载和重写（覆盖）。 方法的重写（Overriding）和重载（Overloading）是Java多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。 Overloaded的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。 ","date":"2018-08-19","objectID":"/java-overload/:3:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":[""],"content":"在windows 和 Unix 上calsspath separator 上是不同的","date":"2018-08-17","objectID":"/classpath-separator/","tags":["",""],"title":"在windows 和 Unix 上calsspath separator 上是不同的","uri":"/classpath-separator/"},{"categories":[""],"content":"calsspath separator 在windows和Unix 上是不同的windows上是分号 直接写java -cp .;junit-4.12.jar Main是会报错的，因为分号代表命令的结束，所以需要用引号括起来 shell不负责命令的解释，它会把这个path原封不动地交给java去处理 git bash 还是windows上的java，所以还是按照分号去分割，只能丢引号里传给java 在unix系统里，分号用于分割两个shell命令 所以这个事情的坑爹之处就在于，git bash里的命令是遵循Unix系统的约定，但是传递给Java程序的classpath分隔符需要遵循windows系统的约定 另外：在cmd上不用引号 javac -cp junit-XXX.jar Main.java这个命令是什么 这个命令里，javac是executable，他的参数是classpath，Main.java是“即将被编译的文件”。Main.java中有一个ActiveTestSuite，那么这个类肯定不能从天上掉下来，要去哪儿找呢，就只能去-cp指定的地方找。 java命令 java -cp .;junit-XXX.java Main Main代表“告诉JVM，要从Main类启动JVM”，那么Main类从哪儿找呢？只能从-cp指定的地方找。JVM运行Main的时候发现，这个引用了ActiveTestSuite，那这个类去哪儿找？也只能从-cp里找 ","date":"2018-08-17","objectID":"/classpath-separator/:0:0","tags":["",""],"title":"在windows 和 Unix 上calsspath separator 上是不同的","uri":"/classpath-separator/"},{"categories":["Java"],"content":"Java异常","date":"2018-08-13","objectID":"/java%E5%BC%82%E5%B8%B8/","tags":["Java"],"title":"Java异常","uri":"/java%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"Java 异常 异常是什么 ： Java异常是Java提供的一种识别及响应错误的一致性机制。是对问题的描述，将问题进行对象的封装。 异常的好处： Java异常机制可以使程序中异常处理代码和正常业务代码分离，在有效使用异常 的情况下，异常能清晰的回答what,where,why这3个问题：异常类型回答了“什么 ”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。 异常两大体系： 异常类都是Throwable的子类。而在Throwable下有两个子类： Error：指的是JVM错误，指此时的程序还没有执行，如果没有执行用户无法处理。 Exception：指的是程序运行中产生的异常，用户可以处理。 * Throwable （所有异常都是从Throwable继承而来。） * Error(错误，无毒) * Exception - checked execption （受检异常，有毒，代表一种预料之中的异常，IOException） * RuntimeException （运行时异常，无毒，代表一种预料之外的异常，因此不需要声明） * catch的级联与合并 异常的抛出原则 能用if/else处理的，不要使用异常 尽早抛出异常 异常要准确、带有详细信息 抛出异常也比悄悄执行错误的逻辑强得多 throw/throws throw 抛出一个异常，用于抛出异常。 throws 只是一个声明，用在方法签名中，用于声明该方法可能抛出的异常。 异常的处理原则 本方法是否有责任处理这个异常？ 不要处理不归自己管的异常 本方法是否有能力处理这个异常？ 如果自己无法处理，就抛出 如非万分必要，不要忽略异常 异常的处理 try / catch / finally 如果没有try，异常将击穿所有的栈帧 catch可以将一个异常抓住 finally执行清理工作 JDK7+： try-width-resources try{ // 有可能出现异常的语句 } [catch(异常类型 对象) { // 处理异常 } catch(异常类型 对象) { // 处理异常 } catch(异常类型 对象) { // 处理异常 } ... ] [finally { // 不管是否出现异常，都执行的统一代码 }] JDK内置的异常 NullPointerException (空指针异常) 调用了未经初始化的对象或者是不存在的对象 ClassNotFoundException (指定的类不存在) NumberFormatException (字符串转换为数字异常) 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据\"111\"转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，“111aa111\"转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. ClassCastException (数据类型转换异常) IllegalStateException IllegalArgumentException (方法的参数错误) IllegalAccessException (没有访问权限) 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 IndexOutOfBoundsException (数组下标越界异常) ArithmeticException (数学运算异常) FileNotFoundException (文件未找到异常) 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出。即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 ArrayStoreException (数组存储异常) 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 Object[] obj = new String[3]; obj[0] = new Integer(0); NoSuchMethodException (方法不存在异常) 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 OutOfMemoryException (内存不足错误) 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 等等 ","date":"2018-08-13","objectID":"/java%E5%BC%82%E5%B8%B8/:0:1","tags":["Java"],"title":"Java异常","uri":"/java%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"Java面向对象","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"对象 对象的行为 —-可以对对象施加那些操作，或可以对对象施加那些方法？ 对象的状态 —-当施加那些方法时，对象如何响应？ 对象标识 —-如何辨别具有相同行为与状态的不同对象？ 类 类（class）是构造对象的模板。由类构造对象的过程称为创建类的是实例。 一个类以 public class开头，public class 代表这个类是公共类，类名必须和文件名相同 public class Merchandise { //类体中可以定义描述这个类的属性的变量。 （成员变量） Sting name; String id; int count; double price; } public class SuperMarket{ public static void main(String[] args){ //使用new操作符，可以创建一个类的实例/对象（instance/object） //使用new创建一个类的实例后，类中定义的每种变量都会被赋以其类型的初始值。 Merchandise m1 = new Merchandise(); //赋值 m1.name = \"这是第一个name\"; m1.id = \"000001\"; m1.count = 10000; m1.print = 88.8; } } 封装 继承 多态 Java是一门面向对象的编程语言，除了基本数据类型以外，Java要求每一个数据类型必须都是一个类。 面向对象的编程思想力图使在计算机语言中对事物的描述与现实世界中该事物的本来面目尽可能地一致，类（class）和对象（object）就是面向对象方法的核心概念。 类是对某一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称实例（Instance）。类和对象就如同概念和实物之间的关系一样，类就好比是一个模板，而对象就是该模板下的一个实例。 面向对象的主要思想是：将客观事物看作具有状态和行为的对象，通过抽象找出同一类对象的共同状态和行为，构成类。 在Java当中申明类都是由class开头的。 ","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"参考 零基础学Java ","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"java基本结构","date":"2018-04-25","objectID":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","tags":["Java"],"title":"Java基本结构","uri":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":" java基本结构 从上到下分为: 包 ** 类** （存放代码基本单元）， 类中包含： ** 静态成员** ** 静态方法** ** 实例变量 ** ** 实例方法** 静态变量 存放在jvm中全局的存储单元， 被所有的有访问权限的对象共享。 静态方法 静态方法可以直接通过类名调用，任何的实例也都可以调用 实例方法 通过对象的实例来调用。 成员变量 和一个对象绑定 在自己类内部可以直接访问 静态变量和静态方法，再别的类中，必须加上类型来访问 ","date":"2018-04-25","objectID":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/:0:0","tags":["Java"],"title":"Java基本结构","uri":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"categories":["读书"],"content":"清醒思考的艺术","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"《清醒思考的艺术》 人是生而自由的，却无往不在枷锁之中。用这句话来描述人类为思维错误所累的情形，也十分恰当精到。思维错误、认知陷阱就像是伴生于人类，细追究起来无处不在，不经意之时又无迹可寻。难道人们注定就要戴着无形的“有色眼镜”看世界吗？不，人们可以思考自己的思考，拒绝思考被污染。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:0:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"自序 我们高估我们的学识要比低估我们的学识频繁的多。失去某种东西的危险要比获得某种东西的前景更能促使我们加快速度。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:1:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"1 幸存偏误 幸存偏误：由于日常生活中更容易看到成功，看不到失败你会系统性地高估成功的希望。 幸存偏误意味着：你系统性地高估了成功概率。 解决办法：尽可能去逛逛曾经大有希望的项目、投资和事业的墓地。这样的散步虽然伤感，但对你是有好处的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:2:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"2 游泳选手身材是错觉 一种错觉:职业游泳者体型完美,并不是因为他们锻炼充分。实际情况正好相反：他们之所以成为出色的游泳选手，是因为他们拥有这样的身材。他们的身躯是一种选择标准，而不是他们运动的结果。 结论：凡有人讴歌某种东西值得追求——强健肌肉、美貌、高收入、长寿、影响力、快乐，你都要看仔细。在跨入泳池之前，不妨先照照镜子。你要诚实地看待自己。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:3:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"3 过度自信效应 我们总是系统性地高估我们的学识和预测能力——而且高估的很厉害。对于过度自信效应，重要的不是单个估计是否正确。过度自信会令你忽视你真正知道的东西与你已知的东西之间的区别。 不存在相反的人不够自信效应。 过度自信效应在男人身上比女人深深更明显——女人较少高估自己。 不仅悲观者会受到过度自信效应的影响，就连自称悲观的人也会高估自己——只不过高估的幅度要少些罢了。 结论：请对所有预测持怀疑态度，尤其是当这些预测是由所谓的专家们作出的。请你在筹建任何事情时都从悲观的角度出发，作最坏的打算。这样你才会真正有机会，更现实一些地判断形势。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:4:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"4 从众心理 从总心理（随大溜）：只要别人做什么我也跟着做什么，我的行为就是正确的。换言之，越多的人认为一个想法正确，这个想法就更加正确——这当然是荒谬的。 英国作家毛姆这样讲到：“就算有5000万人声称某件蠢事是对的，这件蠢事也不会因此成为聪明之举。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:5:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"5 纠缠于沉没成本 每个决定，不管是私人的还是业务上的，始终是在不确定的 情况下作出的。我们的设想，有可能兑现，也有可能落空、任何 时候我们都可能离开选取的小道，并承担后果，比如中断项目。 这种不确定情形下的权衡是理性行为。然而，在我们已经投人特 别多的时间、金钱、能置、爱等因素之后，沉没成本令人难以放 手、难以释怀。于是已经投资的钱就成了继续做下去的理由，即 使客观来看坚持下去毫无意义。投资越多，沉没成本就越大，将 项目继续做下去的理由就越充分。 股市投资人经常成为沉没成本的受害者。他们在决定是否出 售股票时常以买人价作为参照。当股价髙于买入价时，就卖掉股 票；如果股价低于买入价，就抱住不卖。这是不理智的，绝不可 以让买入价处处扮演角色。唯一有效的是股市未来的前景（和可 选投资未来的行情）。每个人都会出错，特别是在股市里。纠缠于 沉没成本的不幸，其关键就是：你投资一只股票亏的钱越多，你 越是抱紧它不放。 为什么会有这种荒谬行为呢？因为人类想努力表现得坚韧， 坚韧是我们发出的可信信号。我们害怕矛盾。如果我们决定中断 —个项目，我们就在制造矛盾：承认从前的想法与今天不同。继 续执行一个无意义的项目是在推迟这一疼痛认识。那样我们就显得更坚韧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:6:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"6 互惠偏误 互惠是风险管理；没有互惠，人类——还有无数种动物——早就灭绝了。 互惠也有可恶的一幕：报复。紧接着报复的是反报复，然后你就会陷入一种恶性循环中。 最近，一个女人向我解释了她在酒吧里为什么不让别人请她 喝饮料：“因为我不想要这种跟他上床的潜在义务。”这样做很明 智。如果下回在超市里有人主动跟你搭讪，让你品尝葡萄酒、奶 酪、火腿或橄榄，你就知道你为什么最好是拒绝他了。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:7:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"7 确认偏误之一 确认偏误是所有思维错误之父一它倾向于这样诠释新信息， 让它们与我们现有的理论、世界观和信念相兼容。换句话说：我们过滤掉与我们的现有观点相矛盾（因此被称作反驳证据，不过 它缺少合适的德语表达）的新信息，这是危险的。赫胥黎说过： “事实不因为被忽视而消失。”但我们恰恰是这么做的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:8:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"8 确认偏误之二 结论：请你与确认偏误作斗争。请你写下你的信条一有关 世界观、投资、婚姻.健康预防措施、节食、成功策略的，然后 寻找反驳证据。干掉自己最心爱的理论，这是一桩艰苦的工作， 但作为聪明人士，你不会躲避的. ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:9:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"9 权威偏误 不管什么时候遇到一位专家，我都会设法向他挑战。请你也这么做。你对权威的批判性越强，你就越自由，就越相信自己有更多的能力。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:10:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"10 对比效应 但对比效应在别处也有效。试验表明，为了节约10欧元，人 们会走10分钟的路去购买一种食物。可是，如果能在街道另一端 花979欧元而不是989欧元买一套西服，谁也不会想到要去走这 10分钟的路，这是一种非理性的行为，因为10分钟还是10分钟， 10欧元还是10欧元 对比效应有时能够毁掉你的整个生活：一个漂亮女人嫁给了 一个相当普通的男人。为什么？因为她的父母都很厉害，她觉得 普通男人更好，虽然他实际上并没有那么好。最后：在超级名模 的广告轰炸下，就连漂亮女人都会觉得自己魅力一般•因此，如 果你是女人，想找一个男人，你千万不要让你的模特儿等级的朋 友陪你一起出去。男人会因此发觉不到你的真实魅力。你独自去 就好。更好的办法是：你带上两个比你难看的朋友去参加舞会。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:11:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"11 现成偏误 你为什么宁可用一张错误的地图，也不愿没有地图 现成偏误是指：我们依据现成的例子来想象世界。这当然是愚蠢的，因为外界现实中的某种东西不会因为我们更容易想到而出现得更频繁。 **壮观、华丽或大声的一切，我们都高估了它们出现的概率。而无声、无形的一切，我们都低估了它们出现得概率。**因为我们的大脑更容易接受壮观、华丽或大声的东西。我们的大脑的剧本式思维的，而不是量化思维的。 应对方法：请与你想法不同的人合作，跟那些与你拥有截然不同经验的人合作。因为你独自战胜不了现成偏误。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:12:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"12 “在好转之前先恶化\"的陷阱 如果有人建议你选择一条“先经历痛苦的道路”，你应该敲响警钟 结论：如果有人说：“在好转之前先恶化”，你脑子里就应该敲响警钟。不过请小心：确实有那样的情形，先是再次下滑然后回升。事业的转换可能会耗费时间，会照成停发工资。一个企业的重组也需要一定的时间。但所有这些情况，人们很快能出措施是否有效。里程碑是明确的，是可以检测的。请你望着里程碑，而不是望着天空 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:13:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"13 故事偏误 结论：从自传到世界大事——我们将一切炮制成有“意义”的故事。我们这样做是在扭曲真相——这会影响我们决定的质量。应对方法：请你将这些故事拆解开来。请你问问自己：这些故事想隐藏什么？训练方法：**请你设法用无关联的眼光看看自己的生平，**你会吃惊的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:14:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"14 事后诸葛亮偏误 事后诸葛亮偏误为什么这么危险呢？因为它让我们相信自己是很好的预言家，而事实却不是这样。这会导致我们傲慢，误导我们作出错误的决定。 但我还有一个建议，这建议更多是来自个人经验而不是科学：请你记日记。请你写下你的预测——有关政治、事业、体重、股市等。请你不时拿你的记载与实际情况相比较。你会惊讶你是个多么糟糕的预言家。另外，请你同样读历史。不是事后的、成熟的理论，而是那个时代的日记、简报、备忘录。这会让你更好地感觉到世界的不可预见性。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:15:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"15 司机的知识 你为什么不可以把新闻播音员说的话当真 查理·芒格认为：知识有两种：一种是真知识，来自那些投入大量时间和思考以获得知识的人们；另一种就是司机的知识，司机是指那些装得好像他们知道的人。他们会模仿别人表演，他们也可能拥有动听的声音或具有说服力的形象。但他们传播的知识是空洞的，他们高谈阔论地挥霍着华丽词汇。 能力范围：在这个范围之内的，人们都像专家一样精通。在这个范围之外的，就不懂或只懂一部分。巴菲特的生活信条是：“请认清你的能力范围，并待在里面。这个范围有多大，并不重要，重要的是知道这个范围的界限在哪里。” 你必须找出自己的才能在哪里。我几乎可以向你保证，如果你必须在你的能力范围之外碰运气，你的职业生涯将会非常糟糕。 真正有知识的人知道他们知道什么，也知道他们不知道什么。这类人一旦来到他的“能力之外”，他要么什么也不说，要么就说“我不知道”。他这么说时不会觉得难为情，甚至还会带着一定的骄傲。而从“司机们”那儿，你别的什么话都能听到，就说听不到这一句。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:16:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"16 控制错觉 控制错觉是指：相信我们能够控制或影响某种我们客观上无法控制或影响的倾向。 请你将注意力集中于你真正能影响的少量东西——坚定不移地只关注其中最重要的那些。其他的，听之任之吧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:17:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"17 激励过敏倾向 人们会对激励机制做出反应。这不奇怪。人都会做对自己有益的事情。令人吃惊的是两个次要方面：第一，一旦有激励加入游戏或改变了激励，人们就会迅速而剧烈地改变自己的行为；第二，人们是对激励做出的反应，而不是对激励背后的目的做出反应。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:18:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"18 回归均值 极端成绩与不太极端的成绩总是来回交替。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:19:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"19 公地悲剧 凡好处归个人而成本由集体承担的地方，就潜伏着公地悲剧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:20:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"20 结果偏误 结论：请你切勿以结果判断决定。结果差不一定意味着当时所作的决定不对，反之亦然。你最好仔细研究一下这样作决定的原因，而不是吐槽一个被证明是错误的决定，或者为一个也许是纯属偶然地获得成功的决定感到庆幸。这个决定是出于理性而作出的吗？如果是，那你下回最好仍然这么做，哪怕上回的结果很糟。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:21:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"21 选择的悖（bei)论 选择范围太大会导致无所适从 选择范围大会导致作出更差的决定。 选择范围大会导致不满。 怎么办？请你在端详面前的选项之前，仔细考虑你想要什么。请你写下你的标准，并务必遵守它们。你要明白，你永远作不出完美的选择。要想作出在事后看来无懈可击的选择是非理性的，因为事情的发展永远有无数种可能性。你就满足于一个适合你的“好答案”吧。是的，在生活伴侣这件事上也是如此。只有最好的才适合你吗？在存在无限选择的年代，情况恰恰相反：适合你的才是最好的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:22:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"22 讨喜偏误 讨喜偏误：指的是某人越讨喜，我们就越倾向于从这个人那儿买东西或者帮助他。 什么是讨喜： 外表有吸引力 在出身、个性和兴趣上与我们相似 他觉得我们讨人喜欢 这三个因素是依次排列的。 结论：你在判断一笔生意时应该坚持不受卖方影响。请你不要考虑他，更好的办法是：请你想象他是个不不讨人喜欢的家伙。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:23:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"23 禀赋效应 禀赋效应：我们感觉我们拥有的东西比我们没有拥有的更有价值。 我们拥有某种东西的事实显然赋予了这样东西额外的价值 请不要死抱着某种东西不放，请将你拥有的视作“宇宙”临时留给你的某种东西。要知道你拥有的一切随时又会被拿走。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:24:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"24 奇迹 不可能事件的必然性 不可思议的意外事件就是虽然少见但完全可能发生的事件。它们的发生没什么可吃惊的，如果它们从不发生，那才令人感到意外。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:25:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"25 团体迷思 共识为什么有可能是危险的 结论：如果你是一个智囊团的成员，无论何时，你都要讲出你的看法——哪怕这看法不是很中听。你要仔细考虑没有讲出的意见，必要时要冒着被隔离在温暖团体之外的风险。如果你领导着一支团队，请你指定某人唱反调。他将不是团队中最受欢迎的人，但也许是最重要的人。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:26:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"26 忽视概率偏误 我们是对一件事的预期强度做出反应，而不是对它的概率。 忽视概率偏误：缺少对概率的直觉理解。 结论： 我们很难区分各种风险，除非风险为零。由于我们不能直觉地理解风险，我们必须计算。在概率公开的地方——像彩票——这就很容易。而在普通生活中，风险很难估计，但又是躲也躲过的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:27:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"27 零风险偏误 零风险偏误：几乎在所有的情况下，人们本来都能更好地投资这笔钱，更显著地降低另一种风险。 结论：请你告别零风险的想象，学会怀着“没有什么是安全的”想法生活——无论是你的积蓄、你的健康、你的婚姻、你的友谊、你的敌人，还是你的土地。请你满足于至少有东西让你保证相对稳定并体验自身的快乐，研究表明，无论是中了百万彩票还是半身瘫痪都不会长期改变你的满意程度。不管发生什么事，快乐的人照样快乐，不快乐的人依旧不快乐。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:28:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"28 稀少性谬误 结论：我们对稀少性的典型反应是丧失清晰思考的能力。因此请你仅按照价格和作用判断一样东西。你不要在乎它是否稀少，是否有其他人也想要它。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:29:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"29 忽视基本概率 精确的描述误导了我们，让冷静的目光偏离了统计真相。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:30:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"30 赌徒谬论 赌徒谬论：人们相信命运具有一种平衡力量。但独立事件不存在平衡的力量。 结论：请你仔细观看，看你面对的是否是独立的事件——不过这主要存在于赌场、彩票和理论的书籍里。现实生活中这些事件大多有着相互联系——已经发生的事情，会影响未来将要发生的事情。因此请你忘记命运的平衡力量（除了回归均值的情形）。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:31:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"31 锚定效应？ 现实生活中，锚定效应随处可见。科学证明，如果老师知道一位学生过去的学习成绩，就会影响他给学生的新论文打分。在这里，过去的成绩起了锚定的作用。许多产品在包装袋上刊印的“建议销售价”也是一个锚定。职业销售人员知道，他们必须先设定一个锚——远在他们报价之前。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:32:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"32 归纳法？ “除了死亡和税收，没有什么是肯定的。” 归纳法有可能具有诱惑性：“人类一直都是成功的，因此我们也将征服未来的挑战。”听起来不错，但我们没有考虑：只有那些幸存到现在的物种才能这么说。以我们存在的事实来说明将来我们也会存在，这是一个严重的思维错误——估计是最严重的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:33:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"33 规避损失？ 规避损失：损失要比同样多的收益对我们的影响更大。 人们害怕失去某种东西的想法要比获得同等价值的东西的想法强烈。 我们无法改变：恶比善更有影响力。我们对不利的东西的反应要比对有利的东西的反应敏感。走在大街上，一张凶恶的脸要比一张友善的脸更容易引起我们的注意。恶性要比善行更久地留存在我们的记忆里。当然也有例外：在事关我们自己的时候。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:34:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"34 社会性懈怠？ 社会性懈怠是一种理性行为：假如使出一半力就行，又不会引起注意，为什么要使出全力呢？ 社会性懈怠是一种让我们自己亏欠所有人的欺骗陌生。这一欺骗大多不是故意的，而是不知不觉地发生的。 可以通过尽可能彰显个人效率，来缓和团队的弊病。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:35:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"35 指数增长？ 结论：当事关增长率时，请不要相信你的感觉。你的感觉是没有用的——请你承认这一点。真正有助与你的是计算器，或者，在增长率小的时候，就是用计算倍增时间的诀窍。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:36:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"36 赢家的诅咒？ 赢家的诅咒：拍卖的赢家大多是事实的输家。 “千万不要参与拍卖。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:37:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"37 基本特征谬误？ 基本特征谬误是指，系统性地高估人的影响，在解释某些东西时低估情境因素。 我们必须理解基本特征谬误：极度关注他人源自我们过去的进化史，隶属于一个群体是生存所必需的，被排斥意味着死亡。繁殖、自卫和狩猎，大多是个体做不到的。我们需要别人协助。特立独行的人——其中肯定有一些——早就在基因池里消失了。因此我们才会这样过度地关注人。我们将90%的精力都用来关注人，只用10%的精力关注情境。 结论：不管戏剧多么让我们着迷，舞台上的人绝非孤立的，他们的表演离不开一个个情境。你要真想理解正在表演的戏剧，就请你不要只注重表演者，而是多关注他们的表演或舞蹈。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:38:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"38 错误的因果关系？ “良好的员工激励会创造更高的企业利润”？果真如此吗？ 相互关系不等于因果关系 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:39:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"39 光环效应？ 光环效应的作用方式总是一样：我们容易得到的或特别明显的因素，自动推论到更难查明的特性。于是，我们倾向于认为一家声誉良好的制造商的产品质量更好，虽然没有客观理由证明此事。 结论：光环效应挡住了我们的视线，让我们看不到真实的特征。因此你要看仔细。请你排除醒目的特征。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:40:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"40 替代途径？ 结论： 风险从来不是一眼就能看到的。因此，请你时刻考虑你有什么样的替代途径。比起你通过无惊险的平凡途径（辛苦工作）获得的成功，别拿通过冒险的替代途径获得的成功太当真。蒙田怎么说来着：“我的生命充满不幸——这些不幸大多没有发生。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:41:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"41 预测的错觉？ “预言未来的人有两种：一种是一无所知的人，另一种是不知道他们自己一无所知的人。” 问题是：专家不必为错误预测付出代价——无论是以金钱损失还是以失去好名声的形式。 结论：请你对预测持批评态度。 英国前首相托尼·布莱尔说：“我不作语言。我从没做过，我永远不会做” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:42:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"42 关联谬误？ 结论：请你忘记“左半脑和右半脑”的说法吧，更重要的是直觉思维和有意识思维之间的区别。直觉思维偏好可信的故事，作重要决定时不顺从它们对你是有好处的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:43:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"43 框架效应？ 结论：你要意识到，没有框架效应，你什么也不能描述，每个事实——不管你是从一位朋友那儿听到的，还是在一份严肃的报刊上读到的——都会受到框架效应的影响。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:44:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"44 行动偏误？ 即使毫无用处，也要采取行动。 社会更喜欢下意识的行动，而不是喜欢有意义的等待。 结论：在不明情形下我们会产生要做点什么的冲动，随便什么——不管它有没有帮助。之后我们会感觉好受些，虽然其实什么也没有好转——事实甚至往往相反。因此，如果情况不明，请你不要采取任何行动，直到你能更好地分析形势。你要克制自己。“人类的全部不幸就是他们不能安静地待在他们的房间里。”帕斯卡尔就曾经这么写到，在他的书房里。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:45:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"45 不作为偏误？ 不作为偏误总是出现在无论放弃还是行动都会带来损害的地方。在这种情况下大多数人都会选择放弃，因为这样引起的损害主观看起来更无害。 不作为偏误很难辨认——放弃行动不像采取行动那么容易看出。我们不得不承认，1968年的欧洲学生运动看穿了不作为偏误，提出了一个醒目的口号来反对它：“如果你不是答案的一部分，你就是问题的一部分。” （如果你不解决问题，那你等于就是在延续问题、加重问题）当然也就成了“问题的一部分” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:46:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"46 自利偏误？ 成功归于自己，失败归于外因。这就是自利偏误。 如何应对自利偏误呢？你有对你直言不讳的朋友吗？如果有，你很幸运。如果没有，那你至少有个死对头吧？好，那你就挑战一下自己，请他喝咖啡，请他不加掩饰地说出对个人的意见。你会永远感激他的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:47:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"47 享乐适应症？ 事业上迈进了一步的人在平均3个月后的幸福感又与先前一样了。就连那些非要驾驶最新款保时捷的人也一样。科学里称这一效应为享乐适应症：我们工作、升迁，给自己购买更多更漂亮的东西，但我们不会变得更幸福。 请你避免很长时间也不会习惯的负面效应，例如往返交通、噪音、慢性疲累等； 请你对物质的东西只期待短期效果，例如汽车、房屋、分红、中彩票、得奖金等； 持续的正面效应主要与你如何利用你的时间有关。 你要设法让自己得到尽可能多的自由时间和自主全。请你做你最爱做的事情——哪怕你要付出部分收入。请你为友谊投资。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:48:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"48 自我选择偏误？ 但我们本身是样品的一部分是，我们必须注意，不要掉进一种以自我选择偏误著称的侍卫错误的陷阱中。 男性抱怨公司女性太少，女性抱怨公司男性太少，这与倒霉毫无关系，因为抱怨着是样品的一部分。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:49:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"49 联想偏误？ 为什么经验有时让人变蠢。 广告将产品与积极的情感联系在了一起。因此你永远不会看到可口可乐与一张不满的脸或一个苍老的身体出现在一起。喝可口可乐的人总是年轻、漂亮、无比快乐。 联想偏误会影响我们作决定的质量。 马克·吐温说：“我们应该注意，一个经历里隐藏了多少智慧，我们就只吸取多少——不要多；好让我们不像坐过热灶台的猫一样。被烫过的猫永远不会再坐到热灶台上去——这是对的；但它永远不会再坐到冷灶台上去了。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:50:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"50 新手的运气？ 假如开始时一起顺利，请务必多加小心。 下面是联想偏误的一种特殊情况：错误地与从前的成功建立联系。赌场的赌客熟悉这一点，他们称这是新手的运气。在游戏的前几轮就输掉的人会倾向于退出游戏；而赢钱的人，就倾向于继续玩下去。这个幸运儿坚信自己拥有超过平均水平的能力，于是他会加大赌注——后来他一下就变成了倒霉蛋，也就是在概率“正常化”的时候。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:51:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"51 认知失调？ 你如何撒点小谎，让自己的感觉好一些。 极不理性的自欺欺人，只能用认知失调来解释。 你还可以尽情地扮演那只狡猾的狐狸——因为你没有吃到葡萄 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:52:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"52 双曲贴现？ 及时行乐——但请只限于星期天 随着时间长度的不同，我们作出的决定是不一致的。科学里称这一现象为双曲贴现。意思是：一个决定离现在越近，我们的“情感利息”就越多。 结论：及时行乐的诱惑力极大——尽管如此，双曲贴现也是一种思维错误。我们越能控制我们的冲动，我们就能成功规避这一错误。我们对我们的冲动控制越小——比如在酒精的影响下——我们就越容易犯这个错误。及时行乐是个好主意——如果每星期一次的话。但天天享受，好像每天都是末日似的，却是不明智的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:53:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"结尾 在群体里容易按照他人的想法生活，在孤独中容易按照自己的想法生活。但值得记住的只是那些在群体中保持独立的人。——爱默生 清醒思考是奢侈的 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:54:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["Java"],"content":"Java运算符","date":"2018-03-09","objectID":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":["Java"],"title":"Java运算符","uri":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Java"],"content":" 运算符对一个或者多个值进行运算，并得出一个运算结果 运算符的运算结果类型有的是固定的，有时候会根据被计算的值变化。比如两个int想加，结果类型就是int。两个byte相加，返回值就是byte。 算术运算符 算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。有加减乘除，取余，自加自减。 public class Test { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(\"a + b = \" + (a + b) ); System.out.println(\"a - b = \" + (a - b) ); System.out.println(\"a * b = \" + (a * b) ); System.out.println(\"b / a = \" + (b / a) ); System.out.println(\"b % a = \" + (b % a) ); System.out.println(\"c % a = \" + (c % a) ); System.out.println(\"a++ = \" + (a++) ); System.out.println(\"a-- = \" + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println(\"d++ = \" + (d++) ); System.out.println(\"++d = \" + (++d) ); } } 关系运算符 == //是否相等 如果相等则条件为真 != //是否相等 如果值不相等则条件为真 \u003e //检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 \u003c //检查左操作数的值是否小于右操作数的值，如果是那么条件为真。 \u003c= //检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 \u003e= //检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 逻辑运算符 逻辑运算符有 \u0026\u0026 逻辑与, || 逻辑或， ! 逻辑非。 public class Test { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println(\"a \u0026\u0026 b = \" + (a\u0026\u0026b)); System.out.println(\"a || b = \" + (a||b) ); System.out.println(\"!(a \u0026\u0026 b) = \" + !(a \u0026\u0026 b)); } } 赋值运算符 常用到的赋值运算符有 = 等于 += 加等于 -= 减等于 *= 乘等于 /= 除等于 等等。 其他运算符 - 条件运算符（三元运算符） - instanceof 运算符 ​ ​ 运算符优先级 () ! *,/,% +,- \u003c=,\u003c,\u003e=,\u003e == != \u0026,\u0026\u0026,|,|| = 位运算符 Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符主要针对二进制，它包括了：“与”、“非”、“或”、“异或”。从表面上看似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要针对两个二进制数的位进行逻辑运算。 ","date":"2018-03-09","objectID":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["Java"],"title":"Java运算符","uri":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Java"],"content":"Java语句和循环","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"条件语句 if-else语法 if-else语法，只有一个语句被执行 if和else都是Java中的关键字 if(boolean 值){ if语句块 }else{ else语句块 } if(boolean 值){ if语句块 }else if(){ if语句块 }else{ else语句块 } switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } ","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/:0:1","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"循环结构 顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。 Java中有三种主要的循环结构： while 循环 while( 布尔表达式 ) { //循环内容 } public class Test { public static void main(String args[]) { int x = 10; while( x \u003c 20 ) { System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); } } } do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 do { //代码语句 }while(布尔表达式); public class Test { public static void main(String args[]){ int x = 10; do{ System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); }while( x \u003c 20 ); } for 循环 让程序在满足某条件时，重复执行某个代码块。for是Java中的关键字 for(初始化; 循环体条件表达式; 循环体后语句) { //代码语句 } public class Example { //for 循环 public static void main(String[] args) { for (int i = 1; i \u003c= 9; i++) { String line = \"\"; for (int j = 1; j \u003c= 9; j++) { if (j \u003e i) { break; } line += i + \"*\" + j + \"=\" + (i * j) + \"\\t\"; } System.out.println(line); } } } public class Example { //for 循环 public static void main(String[] args) { for (int i = 1; i \u003c= 9; i++) { for (int j = 1; j \u003c= i; j++) { System.out.printIn(i + \"*\" + j + \"=\" + (i * j) + \"\\t\") } } System.out.printIn('\\n') } } ","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/:1:0","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"Java基本数据类型","date":"2018-02-18","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["Java"],"title":"Java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Java"],"content":"基本数据类型有： byte 字节型 short 短整型 int 整型 long 长整型 float 单精度浮点 double 双精度浮点 char 字符型 boolean 布尔型 可以分为三类： 数值类型：byte、 short、 int、 long、 float、 double 字符类型：char 布尔型：boolean byte 1、byte是8位的数据类型，占用一个字节（8bit)，默认值是0，它的取值范围是(-2^7) ~ (2^7-1)，也就是 -128 ~ 127之间，所以最大存储数据量是255; 2、byte一般在大型数组中使用，来代替整数，因为byte变量占用的空间只有int的1/4 short 1、short是16位的数据类型，占用2个字节，默认值是0，它的取值范围是(-2^15) ~(2^15-1)，也就是 -32768 ~ 32767之间，所以最大数据存储量是65536; 2、short虽然是int型变量所占空间的1/2，但是在实际中却很少用到。在大型数组中也可以节省空间。 int 1、int是32位的数据类型，占用4个字节，默认值是0，它的取值范围是(-2^31) ~(2^31-1)，也就是 -2147483648 ~ 2147483647之间，所以最大数据存储量是2^32-1; 2、int是数据类型是整型，是我们在项目中用到最多的数据类型之一; long 1、long是64位的数据类型，占用8个字节，默认值是0L，它的取值范围是(-2^63) ~(2^63-1)，也就是 -9223372036854775808 ~ 9223372036854775808之间，所以最大数据存储量是2^64; 2、long是数据类型是长整型，是我们在项目中用到最多的数据类型之一。在使用long类型的数据时最好在数值末尾带上大写的L！ 3、long 使用示例:long a=1000L,long b=-2000L; float 1、float是32位的数据类型，占用4个字节，默认值是0，它的取值范围是3.4e-45 ~ 1.4e38 之间; 2、float是数据类型是单精度，在直接赋值时必须在数字后加上f或F。 3、float使用示例:float a=10.25f, float b=-20.35F; double 1、double是64位的数据类型，占用8个字节，默认值是0，它的取值范围是4.9e-324 ~ 1.8e308 之间; 2、double是数据类型是双精度，在直接赋值的时候最好加上D或d。 3、double使用示例:double a=10.123d, double b= -10.25644D; boolean 1、boolean是布尔类型，占用1个字节，只有两个值,false和true，默认值是 false。 2、boolean只能用一种标志来记录 true或false，一般和 if 结合使用。 3、boolean使用示例: boolean a=true，boolean b=false; char 1、char是字符类型，占用2个字节，默认值为空，取值范围 为 0~65535，也就是 \\u0000 ~ \\uffff。 2、char数据类型可以储存任何字符。 3、char 使用示例: char a=1，char b='A’; ","date":"2018-02-18","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Java"],"title":"Java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":[],"content":"Ubuntu配置Java环境","date":"2017-10-06","objectID":"/ubuntu16.04-study/","tags":["Java"],"title":"Ubuntu16 配置Java环境","uri":"/ubuntu16.04-study/"},{"categories":[],"content":"添加源 添加ppa sudo add-apt-repository ppa:webupd8team/java sudo apt-get update 安装oracle-java-installer sudo apt-get install oracle-java8-installer 设置系统默认jdk sudo update-java-alternatives -s java-8-oracle 官网下载JDK文件jdk-8u171-linux-x64.tar.gz 创建一个目录作为JDK的安装目录 sudo mkdir /java 把下载的文件移入/java目录下 cd 下载地址目录 sudo mv jdk-8u171-linux-x64.tar.gz /java 解压文件 sudo tar -zxvf jdk-8u171-linux-x64.tar.gz 配置环境变量 sudo gedit /etc/environment 在末尾加入JAVA_HOME的路径，即： PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin\" CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib JAVA_HOME=/java/jdk1.8.0_171 保存退出后在运行 source /etc/environment //使环境变量立即生效 或者重启命令行 测试 ▶ java -version openjdk version \"1.8.0_171\" OpenJDK Runtime Environment (build 1.8.0_171-8u171-b11-2-b11) OpenJDK 64-Bit Server VM (build 25.171-b11, mixed mode) ~ ▶ javac -version javac 1.8.0_171 ","date":"2017-10-06","objectID":"/ubuntu16.04-study/:1:0","tags":["Java"],"title":"Ubuntu16 配置Java环境","uri":"/ubuntu16.04-study/"},{"categories":[],"content":"Win7 安装 Mongodb","date":"2017-09-23","objectID":"/win7-install-mongodb/","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"下载安装 mongodb官网下载地址：[hhttps://www.mongodb.com/download-center](https://www.mongodb.com/download-center) 直接下载.msi文件并安装到指定目录即可。我的安装路径是D:\\mongodb 然后在根目录下新建一个blog文件夹，作为数据存放目录（网上的教程多命名为data，你们随意，自己知道就行）。 同时在根目录下新建一个logs文件夹，作为日志文件存放处。 现在看起来可能是这样子的： |-D: |-mongodb |- blog |- logs ","date":"2017-09-23","objectID":"/win7-install-mongodb/:1:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"设置系统变量 这一步的目的在于可以直接在cmd控制台执行mongod命令，而不需要一路cd到\\bin目录才能执行。 我的电脑--属性--高级系统设置--环境变量--系统变量，找到PATH，双击编辑，在末尾加上;D:\\MongoDB，注意前面加分号，最后点击确定即可 ","date":"2017-09-23","objectID":"/win7-install-mongodb/:2:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"启动mongodb 现在，我们可以直接cmd打开命令行，直接输入 mongod --dbpath=D:\\MongoDB\\blog，若输出的末尾有这一句则代表mongodb已经成功启动，端口号为27017。 我们在浏览器输入localhost:27017，页面将显示“It looks like you are trying to access MongoDB over HTTP on the native driver port.”表示启动成功。 这时候新开一个命令行窗口，就可以直接执行mongo的指令了。 ","date":"2017-09-23","objectID":"/win7-install-mongodb/:3:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"更快捷的方式 通过以上步骤，我们解决了“一路cd”的问题，但是启动mongodb还是需要写mongod --dbpath=D:\\MongoDB\\blog。 我们可以把mongodb作为开机启动任务，随系统开启而开启！ 打开cmd控制台，输入 mongod --dbpath=D:\\mongodb\\blog --logpath=D:\\mongodb\\logs\\mongodb.log --install 这时候在\\logs文件夹内就会出现一个mongodb.log文件，里面是mongodb的一些日志。 现在mongodb已经可以随系统启动了。以后我们需要连接mongodb数据库，只需要在cmd控制台输入net start mongodb， 需要关闭mongodb，只需要输入net stop mongodb ","date":"2017-09-23","objectID":"/win7-install-mongodb/:4:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"下载msi 默认安装 安装mongodb服务端 示例安装目录：C:\\Program Files\\MongoDB 用管理员打开命令行： Win+R--\u003ecmd 创建mongodb数据库和日志文件目录（自定在c盘下创建data文件夹） mkdir c:\\data\\db mkdir c:\\data\\log 创建配置文件（日志配置、数据库配置） echo logpath=c:\\data\\log\\mongod.log\u003e \"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\" echo dbpath=c:\\data\\db\u003e\u003e \"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\" 创建mongodb服务（创建后自动生成服务 services.msc） sc.exe create MongoDB binPath= \"\\\"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.exe\\\" --service --config=\\\"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\\\"\" DisplayName= \"MongoDB\" start= \"auto\" 启动mongodb服务 net start MongoDB ","date":"2017-09-23","objectID":"/win7-install-mongodb/:5:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":["JavaScript"],"content":"npm 一些配置","date":"2017-08-23","objectID":"/npm-config/","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm 小技巧 运行 npm config set loglevel http， npm 发出的请求 运行 npm config set progress false，关闭进度条 运行 npm config set registry https://registry.npm.taobao.org/ 这会让你在运行 npm adduser 的时候出问题，想要恢复成原样，只需要 npm config delete registry 即可 还原 npm config set registry https://registry.npmjs.org/ ","date":"2017-08-23","objectID":"/npm-config/:0:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"清除缓存 npm cach clean --force ","date":"2017-08-23","objectID":"/npm-config/:1:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"node-sass 安装失败 $ npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ ","date":"2017-08-23","objectID":"/npm-config/:2:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"chromedriver_win32 下载失败 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver ","date":"2017-08-23","objectID":"/npm-config/:3:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm scripts 规则 \"scripts\": { \"lint\": \"eslint --fix --ext .js,.vue src\", }, eslint --fix 可以按照eslint规则自动格式化 Module build failed: Error: No parser and no file path given, couldn’t infer a parser 的错误。 rm -rf node_modules npm install npm install prettier@~1.12.1 ","date":"2017-08-23","objectID":"/npm-config/:4:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm 常用的包 nodemon bcrypt jsonwebtoken http-assert pm2 ","date":"2017-08-23","objectID":"/npm-config/:5:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["HTML"],"content":"使用原生JavaScript完成一个Tab切换 ","date":"2017-03-09","objectID":"/javascript-tab/:0:0","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"代码结构 ","date":"2017-03-09","objectID":"/javascript-tab/:1:0","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"html \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003cli\u003e选项4\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003cli\u003e内容4\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003cli\u003e选项4\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003cli\u003e内容4\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ","date":"2017-03-09","objectID":"/javascript-tab/:1:1","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"css ul, li { margin: 0; padding: 0; } li { list-style: none; } .clearfix:after { content: ''; display: block; clear: both; } .tab { width: 600px; margin: 20px auto; border: 1px solid #ccc; padding: 20px 10px; border-radius: 4px; } .tab-header { border-bottom: 1px solid #ccc; } .tab-header\u003eli { float: left; color: brown; border-top: 1px solid #fff; border-left: 1px solid #fff; border-right: 1px solid #fff; padding: 10px 20px; cursor: pointer; } .tab-header .active { border: 1px solid #ccc; border-bottom-color: #fff; border-radius: 4px 4px 0 0; color: #333; margin-bottom: -1px; } .tab-container { padding: 20px 10px; } .tab-container\u003eli { display: none; } .tab-container\u003e.active { display: block; } .box { height: 1000px; } ","date":"2017-03-09","objectID":"/javascript-tab/:1:2","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"js let headerList = document.querySelectorAll('.tab-header li'); let panelList = document.querySelectorAll('.tab-container li'); //forEach的callback传入三个参数：currentValue、index、array headerList.forEach(function(headerLi){ headerLi.onclick = function(e){ //当点击当前元素是，所有的元素去掉active let currentLi = e.target; headerList.forEach(function(li){ li.classList.remove('active'); }) //当前的元素加上active类,由于headerList是类数组对象所以需要call数组方法indexOf let index = [].indexOf.call(headerList,currentLi); headerList[index].classList.add('active'); //隐藏所有panelList，并显示当前panel panelList.forEach(function(panel){ panel.classList.remove('active'); }) panelList[index].classList.add('active'); } }) ","date":"2017-03-09","objectID":"/javascript-tab/:1:3","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"jQuery $('.tab-header\u003eli').on('click',function(){ let $this = $(this); $panels = $this.parents('.tab').find('.tab-container\u003eli'), index = $(this).index(); $this.siblings().removeClass('active'); $this.addClass('active'); $panels.removeClass('active'); $panels.eq(index).addClass('active'); }) ","date":"2017-03-09","objectID":"/javascript-tab/:1:4","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"封装 function Tab(ct) { this.ct = ct; this.init(); this.bind(); } Tab.prototype.init = function () { this.headerList = this.ct.querySelectorAll('.tab-header\u003eli'); this.panelList = this.ct.querySelectorAll('.tab-container\u003eli'); } Tab.prototype.bind = function () { let _this = this; //把this暂存起来 this.headerList.forEach(function (headerLi) { headerLi.onclick = function (e) { let currentLi = e.target; _this.headerList.forEach(function (li) { li.classList.remove('active'); }) let index = [].indexOf.call(_this.headerList, currentLi); _this.headerList[index].classList.add('active'); _this.panelList.forEach(function (panel) { panel.classList.remove('active'); }) _this.panelList[index].classList.add('active'); } }) } let tab1 = new Tab(document.querySelectorAll('.tab')[0]); let tab2 = new Tab(document.querySelectorAll('.tab')[1]); let tab3 = new Tab(document.querySelectorAll('.tab')[2]); //当创建了对象之后就会创建一个空对象，然后把这个对象的_proto_属性指向Tab.protitype。然后再将 //执行构造函数里的this初始化。 ","date":"2017-03-09","objectID":"/javascript-tab/:1:5","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"}]