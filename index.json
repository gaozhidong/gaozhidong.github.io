[{"categories":["HTML"],"content":"HTML + JS 的一个 弹窗 .","date":"2017-03-06","objectID":"/javascript-modal/","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"HTML + JS 的一个 弹窗 ","date":"2017-03-06","objectID":"/javascript-modal/:0:0","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"代码结构 ","date":"2017-03-06","objectID":"/javascript-modal/:1:0","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"html \u003cdiv id='one'\u003e \u003cbutton id='btn'\u003e点我\u003c/button\u003e \u003c/div\u003e \u003cdiv id='two'\u003e \u003cbutton id='btn'\u003e不要点我\u003c/button\u003e \u003c/div\u003e \u003cdiv id='three'\u003e \u003cbutton id='btn'\u003e我是第三个\u003c/button\u003e \u003c/div\u003e ","date":"2017-03-06","objectID":"/javascript-modal/:1:1","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"css * { margin: 0; padding: 0; } .overlay { width: 100%; height: 100%; background: rgba(0, 0, 0, 0.3); position: fixed; left: 0; top: 0; } .floatwin { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 350px; background: #FFF; left: 50%; border-radius: 4px; } .clear:after { content: ''; display: block; clear: both; } .header { padding: 8px 10px; border-bottom: 1px solid #ccc; } .header\u003espan { float: right; margin: 0; cursor: pointer; } .content { padding: 20px 10px; } .content\u003ep { line-height: 1.5; } .footer { border-top: 1px solid #ddd; padding: 0px 10px; } .footer\u003espan { display: inline-block; float: right; margin: 10px 0px 10px 10px; cursor: pointer; } ","date":"2017-03-06","objectID":"/javascript-modal/:1:2","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":["HTML"],"content":"js var Modal = (function () { function _Modal(ct, header, content) { this.ct = ct this.header = header this.content = content this.init() this.bind() } _Modal.prototype = { init: function () { var div = this.div = document.createElement('div') div.innerText = '1' this.html = '\u003cdiv class=\"overlay dis close\"\u003e' this.html += '\u003cdiv class=\"floatwin \"\u003e' this.html += '\u003cdiv class=\"header clear\"\u003e' this.html += '\u003cspan class=\"close\"\u003eX\u003c/span\u003e' this.html += '\u003ch4\u003e' + this.header + '\u003c/h4\u003e' this.html += '\u003c/div\u003e' this.html += '\u003cdiv class=\"content\"\u003e' this.html += '\u003cp\u003e' + this.content + '\u003c/p\u003e' this.html += '\u003c/div\u003e' this.html += '\u003cdiv class=\"footer clear\"\u003e' this.html += '\u003cspan\u003e确定\u003c/span\u003e' this.html += '\u003cspan class=\"close\"\u003e取消\u003c/span\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e' div.innerHTML = this.html console.log(this.html) }, bind: function () { var _this = this console.log(this.ct.querySelectorAll('.close').length) this.ct.querySelector('#btn').addEventListener('click', function (e) { e.stopPropagation(); _this.ct.appendChild(_this.div) }) for (i = 0; i \u003c this.div.querySelectorAll('.close').length; i++) { console.log(1) this.div.querySelectorAll('.close')[i].addEventListener('click', function (e) { e.stopPropagation(); console.log(1) _this.div.parentNode.removeChild(_this.div) }) } this.div.querySelector('.floatwin').addEventListener('click', function (e) { e.stopPropagation(); }) } } return { add: function (ct, header, content) { new _Modal(ct, header, content) } } })() Modal.add(document.querySelector('#one'), '标题啦', '内容啦') Modal.add(document.querySelector('#two'), '标题啦2', '内容啦2') Modal.add(document.querySelector('#three'), '标题啦3', '内容啦4') ","date":"2017-03-06","objectID":"/javascript-modal/:1:3","tags":["JavaScript","HTML"],"title":"弹窗","uri":"/javascript-modal/"},{"categories":[],"content":"关于 ","date":"2020-10-22","objectID":"/about/:0:0","tags":[],"title":"Index","uri":"/about/"},{"categories":[],"content":"关于","date":"2020-10-22","objectID":"/about/:1:0","tags":[],"title":"Index","uri":"/about/"},{"categories":["转载"],"content":"编程经验","date":"2020-06-21","objectID":"/programming-experience/","tags":["转载"],"title":"转载 - 编程经验谈","uri":"/programming-experience/"},{"categories":["转载"],"content":"编程经验谈 转载自幻神博客 设计 在没有足够多的具体实例之前，先不要急着建立抽象 别做一般性的考虑，先考虑清楚到底要覆盖哪些目标场景 如果你没写过自己的编程语言，那就尽量别碰 DSL 经历比资历重要，除非以前做过，否则大家都是拿不定主意 大部分人并没有十年的编程实战经验，所以要相信自己的判断 不论你设计的多么好，总有人能指出他认为不好的地方 项目 不要乱动别人写的代码，尤其是不要删那些看起来没用的逻辑 项目中遇到的问题，大多不是技术问题，而是人的利益冲突 永远无法兼顾所有人的利益，所以重要是自己决定怎样做 不存在足够好的理想中的团队环境，换一个团队只是换一些问题 项目就是用不完美的办法尽量达成目的的过程，因此总有令人不满意的地方 债务总是会有的，区别是积累一段时间后偿还，还是随时偿还 代码 只靠代码本身，无法进一步提高代码的可读性 可维护性是玄学，人们都认为只有自己的代码才更好维护 好代码是有代价的，洁癖是不可取的，我们需要的不是代码而是功能 把代码写正确，比把代码写优雅更重要 著名项目里的代码，并不比你写的好 不存在看不懂的代码，再烂的代码多少也能看懂一点，静下心来看下去很重要 产品 解决问题的时候，还要关注问题是怎么定义的 问题有时候并不需要被解决，找到提出问题的人 亲手用一用自己的产品，避免“亲爱的用户，我是你爹” 没有该不该做的事情，只有轻重缓急 需求不可能不变，因此不是要禁止变更，而是要对变更进行管控 对于究竟怎样做更好，产品经理有时候也不能确定，只是他必须表现出确定 做事 疼痛需由当事人自己说出来，要关心用户但也不要替别人拿主意 不要勉强采用别人的方案解决问题，自己的事情自己负责，不认可就别接着做 我们都是公司的资源，因此不要以浪费资源的方式开展工作 别人不是反对我们的方案，而是反对我们给他们造成的麻烦 专业技能千篇一律，办事能力千差万别 事情能进展下去，不是因为本身是对的，而是各参与者都能得到自己想要的 学习 程序猿是在帮别人解决问题，而不是自己 开发者的时间不是自己的，公司不是学习的地方 没有纯技术团队，总得做一些不想做的事情 你觉得需要学的，是别人想让你学的 工作不止编程这么简单，不要用十年只学编程 编程是一个不断学习的过程，除了学习通用知识之外，还要学团队成员创造的知识 ","date":"2020-06-21","objectID":"/programming-experience/:0:0","tags":["转载"],"title":"转载 - 编程经验谈","uri":"/programming-experience/"},{"categories":null,"content":"一键将package.json中的模块更新到最新版本","date":"2020-06-02","objectID":"/npm-update/","tags":["npm"],"title":"一键将package.json中的模块更新到最新版本","uri":"/npm-update/"},{"categories":null,"content":"更新依赖 npm i -g npm-check-updates ncu -u npm install ","date":"2020-06-02","objectID":"/npm-update/:0:0","tags":["npm"],"title":"一键将package.json中的模块更新到最新版本","uri":"/npm-update/"},{"categories":["读书"],"content":"这是描述","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"《黑天鹅》 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:0:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"规避突发的事件对自身的影响 预防比事后弥补/事中救火要重要的多，对突发事件最坏结果做好预防，降低对正常事件的影响。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:1:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"个人认知的局限性 认知是片面的，局部的，带有局限性。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:0","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"静态思维与动态思维 事物处于运动之中。 静态思维容易将过去的，片面的标签来描述现在的事物，而忽略了事物的运动性，发展性，即使是微小的，持续的变化在时间的加持下也能引起质变。例如西方国家对亚非国家的刻板印象。 很多事物往往处于复杂的系统中，事物之间互相影响。所以决策时要运用动态思维考虑决策将会引起的一系列连锁。例如政府新颁布的政策，正所谓上有政策下有对策。 延伸： 对自身认识的高估、对现实情况的低估； 当局时容易盲从。习惯从结果后再推理逻辑，使事件符合所谓因果； 过于依赖所谓权威专家的结论，自己却未进行深层思考辩证。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:1","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"假如你不会预测怎么办 假如你抛弃完全准确地预测未来的想法，你就有很多事情可以做，只要你记住预测的局限性。知道你无法预测，并不意味着你不能从未来的不可预测性中获益。 建议很廉价，非常廉价 作好准备！狭隘的预测有麻痹或治疗的作用。小心那些神奇数字的麻痹作用。对所有可能的结果作好准备。 把生活中美好的偶遇最大化。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:2","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"平均斯坦和极端斯坦 平均斯坦大概就是“一把筷子难折断”这条谚语的同类，团结力量大，集体影响小。 极端斯坦就是木桶理论里的短板效应的亲兄弟啊，意外突如其来，无从总结规律。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:3","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"经验主义和现实世界的复杂性 经验主义就是拿过去已知的东西来解决未知的情况，然而现实世界可能存在的“黑天鹅”可能会把之前所有的所谓逻辑轨道推翻。 向内看到自身的缺陷，向外看到世界的复杂性；所以成熟客观理智的方式是不草率对事物下决定性定论。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:4","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"黑天鹅事件的定义 黑天鹅事件原因: 世界的不确定性，信息不对称，认知有缺陷，决策非理性，系统复杂性。 人们愿意相信更加精确的事情发生概率更高，但按概率来说越精确意味着条件越严苛，应该是概率更小的事件，这就是所谓的精确的错误和模糊的准确。 讲故事比单纯给出一个数字更有效果，故事直观而立体，数字平面且干瘪。 你的肢体语言和表情管理是可以控制别人对你所要表达内容的质量的看法甚至于忽视你目前的不利情势。你的冷静与表露出的淡淡傲然则会给别人留下深刻印象。所以说话的方式成就你的人格魅力。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:5","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"信息是有偏差的 应该从过去的经验和教训中吸取教训，而不是喝过去经验的鸡汤。 历史都是由赢家书写的，我们只看到了他们如何成功，却不去学习失败者为何失败，成功者成功是多因素甚至种种巧合汇聚起来才能成功，而失败则可能有一种原因便可失败。 信息是有偏差的: 在我们进行天分比较时，经常忽略沉默的证据，尤其在那些受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事，但太把它们当回事是不应该的，因为我们并没有看到全部事实。 人们往往根据自己的需要去选择样本，为自己寻找支撑理由和借口。看到的和听到的都是经过过滤后的信息，并不代表事物的真相。 我们能看到政府做了什么，因此歌颂他们，但我们没有看到别的。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:6","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"对于风险的认知 对沉默证据的认识偏差降低了我们对我们在过去招致的风险的认识，尤其是有幸躲过了那些风险的人。你的生命曾遭受严重威胁，但你幸存下来，于是你在事后会低估情况的实际危险性。 短暂的成功可能会让你松懈，其实这次成功真可能是个侥幸，并代表不了什么，如果松懈，很可能在下一次黑天鹅事件中消失，直到人们忘记。 进化是一系列侥幸的成功，有好的，也有不好的。你只看到了好的。但在短期内，哪些真正对你是好的并不明显，当你处在会产生黑天鹅现象的极端斯坦环境下时尤其如此。 当你觉得不知如何选择的时候，可能不选择都比盲目选择更容易避免盲目承担风险。冒险不可怕，可怕的是对结果的多样性毫无意识。 不要高估个人能力和知识，不要低估不确定性的风险。保持谦虚以及不安全感。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:7","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"思维的误区 我们的思维是有惯性的：一旦形成一个观点，我们就很难改变，所以情况对那些推迟形成观点的人更有利。 后视镜视觉：看着后视镜来开车，结果肯定会翻车嘛！这个类比就如看着过去的数据来判断未来的数据。在股票市场就最常见了 来源于信息本身的特性。我已经说过，黑天鹅现象有三个特点：不可预测，影响重大，事后可解释。 1.我们既爱筛选，又爱进行“狭隘”的思考（认知自大）； 2.我们的预测能力被大大高估，许多认为自己能够预测的人实际上不具备这一能力。 所以真正的热爱生活要看到世界的阴暗面，成功的投资要看到负面的东西，真正的积极是在逆境中。 每增加一个变量，系统的复杂性便随之上升，预测的难度便随之增加！ 根据过去预测未来的问题可能比我们已经讨论的问题还要严重，因为相同的过去的数据既可以证明一个理论，又可以同时证明完全相反的理论！如果你明天还活着，这可能意味着你更可能长生不老，或者你更接近死亡。 不要指望一个巨大的幸福会让我们长期快乐，而是不断的来点小确幸。对于痛苦则反之，长痛不如短痛。 一件事情能做的标准是，不是它的结果好到什么程度，而是它的危害能不能承受，换言之，未虑胜先思败。 工作从来都没有真正的稳定性可谈，但能力却是永远保值的。 一个银行职员可能因为没有能力被人工智能淘汰，而有能力的咨询师却可以在种种风险中不断前行。 波动性让人更容易走在舒适区，同时有着更强的抗风险能力。 这也是在同样面临失业时，咨询师可以比公务员银行职员更快走出危机的原因。 做决策时，你只需要了解事件的影响（这是你能知道的），不需要了解事件的可能性（这是你不可能知道的），这一思想就是不确定性的核心思想。我生活的大部分都以它为基础。 无法理解正在发生什么，即从源头开始走错方向，难以预测。认知自大-盲目性+柏拉图式的分类+错误的推理方法。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:8","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"正态分布（钟形曲线）和极端事件 分布性带来健壮性。集中性带来效率性。以最高效率进行组织形式的构建，并投入极高精力维护稳定，却依然不能避免不确定事件的发生。绝对的集中带来的是小概率的超高风险。 正态分布（钟型曲线）有其适用的条件。 一、结果是由多个（越多越好）变量相加而得的； 二、每个变量是独立的，相互之间不能有影响； 三、每个变量对于结果的贡献是有限的； 人的身高就满足以上条件。身高是由至少180个基因共同决定的，这些基因基本是相互独立的，而身高是所有这些因素相加之和。 在正态分布中，极端事件确实是极其罕见的，你真的不必要去为所有可能做准备，否则你根本就承受不了应对的成本。 而当变量之间是不独立的，存在相互影响时，就不是正态分布了，而是幂律分布。幂律分布下，你必须做好准备迎接极端事件，这里就是极端斯坦。 马太效应就是最好的例子，排行榜越是靠前的书，就会有越多的人购买，每一次的购买行为都会受之前销量的影响。 古斯塔夫也说，能有效煽动大众情绪从而领导他们的，不是正确的道理和理论，而是激情、富于感染力的口号，哪怕这口号经不起推敲。 较大不确定性原则就是，一叶障目，不见泰山，只见树木，不见森林。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:9","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"冗余和高效率的矛盾 多策略多计划，备份方案的重要性，防御性冗余: 冗余就意味着保险。尽管看上去有些效率低下，但这是为了维护这些备件，并具备足够的保有这些备件的能量，尽管它们平时处于闲置状态。 所谓高效率，也就是说把冗余去除掉，从而提高了效率，冗余就相当于企业的现金流，现金流充裕，也就可以抵御金融风险了。效率与冗余是对立的，效率高则冗余低 拥有众多辅助功能的东西会从环境任意性和认知不透明性中受益匪浅。 人们更愿意突然性地失去很多，而不愿意每一步失去少量；人们在痛苦到一定程度，会变得麻木。因此，不愉快的经历（比如在新泽西逗留）应当越集中、越浓缩越好。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:10","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["读书"],"content":"信息的不对称和看待信息角度差异 对于火鸡来说就是黑天鹅现象，但是对于屠夫来说是日常操作。信息的不对称和不同的角度看待问题差别巨大。 就好像计划赶不上变化一样，之前说过的计划与现实的偏离都会有所偏差，时间越长，项目越大，偏差也就越大。 对于不确定性的这种两极分化一种产生的宿命论，一种认为无所谓，而实际上呢，对于这个本体随意性和你的认知随意性的偏差是非常非常大的。 罕见事件发生的频率不能通过经验观察来预测，原因是它们太罕见了。因此，我们需要一个先验模式来代表它；事件越罕见，使用标准的归纳方法（比如通过例数过去发生的事情进行频率抽样）进行预测的错误便越严重，同时对于能延伸至低可能性事件（这类事件当然不常见）领域的先验代表的依赖度也便越高。 世界上不到0.25%的上市公司代表着大约一半的市场资本化，世界上极少部分的小说占据了约半数的小说销量，不到0.1%的药品为制药工业赢得了超过一半的利润——同样，不到0.1%的风险事件会引发至少一半的破坏与损失。 在极端情况下，可以预测失败但无法预测失败造成的损失的规模，也许是指数级的误差。所以小心驶得万年船。 考证的担子要落在破坏复杂体系的人身上，而不是保持现状的人身上。 保持一份专业的同时也得学会涉猎其它领域，没有谁规定医生是不能当银行家的。 避免低可能性盈利的预测——尽管对一般盈利没有必要。 ","date":"2020-03-05","objectID":"/%E9%BB%91%E5%A4%A9%E9%B9%85/:2:11","tags":["读书"],"title":"《黑天鹅》","uri":"/%E9%BB%91%E5%A4%A9%E9%B9%85/"},{"categories":["Java"],"content":"Java学习资料总结","date":"2019-11-23","objectID":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/","tags":["Java"],"title":"Java学习资料总结","uri":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/"},{"categories":["Java"],"content":" 雇佣 Java 程序员的完整指南（英文） Java 程序员招聘非常常见，本文总结了企业对于初级、中级、高级、架构师各个级别的 Java 程序员应该考察哪些方面。 java-design-patterns 一个开源仓库，收集 Java 语言的各种编程模式。 Java 开发者需要知道的20个库（英文） 本文介绍 Java 语言20个常用的库，比如 log4j、JUnit、JSoup 等。 巡云轻论坛系统 Java + MySQL 开发的一个论坛程序，自适应手机端和电脑端，界面简洁，功能完整 10本 Java 语言好书 这个书单推荐了10本学习 Java 语言的必读书，前三名是 Effective Java、Clean Code 和 Java Concurrency in Practice。 Java 的类 Java 语言以众多的类著称，但是你知道它一共有多少个 public Class 吗？ 为什么选择 Java 作为后端开发语言？（英文） 本文介绍了 Java 语言用在后端开发的一些优势。 JCSprout 一个收集 Java 核心知识的中文库。 MyPerf4J Java 应用的性能监控工具 Java 语言如何实现线程间通信（英文） 一篇简单的教程，Java 语言如何实现多线程编程。 advanced-java（中文） Java 互联网开发的知识笔记，涉及MQ、ES、Redis等周边工具。 互动式计算机语言学习网站 该网站提供近10种常用语言（C、Python、JS、Java 等等）的实例教程 在线学习java 记忆语法 ","date":"2019-11-23","objectID":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/:0:0","tags":["Java"],"title":"Java学习资料总结","uri":"/java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93/"},{"categories":["HTML"],"content":"重新学习HTML","date":"2019-11-05","objectID":"/html/","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"1、简述一下 src 与 href 的区别 href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置； 在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 ","date":"2019-11-05","objectID":"/html/:1:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"2、html 中 title 属性和 alt 属性的区别 ？ 有title,那么无论图片能不能正常显示，鼠标放上去都会出现title。有alt，当图片不能正常加载的时候，会显示alt内容。 \u003cimg src=\"#\" alt=\"alt 信息\" /\u003e 当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。 当图片正常读取，不会出现 alt 信息。 \u003cimg src=\"#\" alt=\"alt 信息\" title=\"title 信息\" /\u003e 当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。 当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。 ","date":"2019-11-05","objectID":"/html/:2:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"3、讲述你对 reflow回流 和 repaint重绘 的理解 原因：浏览器渲染机制 戳戳戳，你真的了解回流和重绘吗? 严重性： 在性能优先的前提下，性能消耗 回流 大于 重绘 体现：repaint 是某个 DOM 元素进行重绘；reflow 是整个页面进行重排，也就是页面所有 DOM 元素渲染。 如何触发： style 变动造成 重绘 和 回流 1、重绘 ： color 的修改，如 color=#ddd text-align 的修改，如 text-align=center a:hover 也会造成重绘 :hover 引起的颜色等不导致页面回流的 style 变动 2、回流： width/height/border/margin/padding 的修改，如 width=778px； 动画，:hover 等伪类引起的元素表现改动，display=none 等造成页面回流； 对可见的DOM元素操作； 插入、删除元素，appendChild 等 DOM 元素操作； font 类 style 的修改； background 的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分 background 的修改只触发 repaint，当然 IE 不用考虑； scroll 页面，这个不可避免； resize 页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize 程序窗口大小的多窗口操作系统。 读取元素的属性：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight……），当你获取布局信息的操作的时候，会强制队列刷新 3、如何避免： 尽可能不要用js来控制DOM来修改style、合并多次对DOM操作（减少for循环） 如果要实现动画，用position：absoulte/fixed 脱离文档流，这样受影响的只有当前元素 避免使用 table 进行布局：table 的每个元素的大小以及内容的改动，都会导致整个 table 进行重新计算，造成大幅度的 repaint 或者 reflow。改用 div 则可以进行针对性的 repaint 和避免不必要的 reflow。 对布局样式属性获取最好将其值缓存起来，避免重复计算 避免在 CSS 中使用运算式：这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的 repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。 牺牲平滑度满足性能：动画精度太强，会造成更多次的 repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。 注意：回流一定会触发重绘，而重绘不一定会回流 ","date":"2019-11-05","objectID":"/html/:3:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"4、HTML5 为什么只需要写 \u003c !DOCTYPE HTML\u003e ？ HTML5 不基于 SGML(标准通用标记语言（以下简称“通用标言”)，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 ","date":"2019-11-05","objectID":"/html/:4:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"5、行内元素有哪些 ？块级元素有哪些 ？ 空(void)元素有那些 ？ CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值。 如 div 的 display 默认值为 “block”，则为“块级”元素； span 默认 display 属性值为 “inline”，是“行内”元素。 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p 常见的空元素： img input link meta br hr ，鲜为人知的是：area base col command embed keygen param source track wbr ","date":"2019-11-05","objectID":"/html/:5:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"6、HTML5 有哪些新特性？如何处理 HTML5 新标签的浏览器兼容问题 ？ 新特性： 1、绘画 canvas; 2、用于媒介回放的 video 和 audio 元素; 3、本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; 4、sessionStorage 的数据在浏览器关闭后自动删除; 5、语意化更好的内容元素，比如 article、footer、header、nav、section; 6、表单控件：calendar、date、time、email、url、search; 7、新的技术：webworker, websocket, Geolocation; 支持 HTML5 新标签： 1、IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 2、然也可以直接使用成熟的框架、比如 script 引入 html5shim; ","date":"2019-11-05","objectID":"/html/:6:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"7、简述一下你对 HTML 语义化的理解 ？ 1、用正确的标签做正确的事情。 2、html 语义化让页面的内容结构化，结构更清晰， 3、搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; ","date":"2019-11-05","objectID":"/html/:7:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"8、请描述一下 cookies，sessionStorage 和 localStorage 的区别 ？ 作用区别： cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。在同源的 http 请求中携带（即使不需要），也会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 ","date":"2019-11-05","objectID":"/html/:8:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"9、iframe 内嵌框架有那些缺点 ？ 内联框架 iframe 一般用来包含别的页面，例如 我们可以在我们自己的网站页面加载别人网站的内容，为了更好的效果，可能需要使 iframe 透明效果； iframe 会阻塞主页面的 onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。 ","date":"2019-11-05","objectID":"/html/:9:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"10、Label 的作用是什么？是怎么用的 ？ label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 和 for 功能使用 \u003clabel for=\"Name\"\u003eNumber:\u003c/label\u003e \u003cinput type=\"“text“\" name=\"Name\" id=\"Name\" /\u003e \u003clabel\u003eDate:\u003cinput type=\"text\" name=\"B\"/\u003e\u003c/label\u003e ","date":"2019-11-05","objectID":"/html/:10:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"11、如何实现浏览器内多个标签页之间的通信 ? WebSocket、SharedWorker； 也可以调用 localstorge、cookies 等本地存储方式； localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信； ","date":"2019-11-05","objectID":"/html/:11:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"12、网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序； 可以防止恶意、暴力破解密码、刷票、论坛灌水； ","date":"2019-11-05","objectID":"/html/:12:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"13、前端页面有哪三层构成，分别是什么？作用是什么？ 网页分成三个层次，即：结构层、表示层、行为层。 网页的结构层（structurallayer）由 HTML 或 XHTML 之类的标记语言负责创建。 网页的表示层（presentationlayer）由 CSS 负责创建。CSS 对“如何显示有关内容”的问题做出了回答。 网页的行为层（behaviorlayer）由Javascript负责回答 “内容应该如何对事件做出反应” 这一问题。 ","date":"2019-11-05","objectID":"/html/:13:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"14、盒子模型的理解 ? CSS 盒子模型具有内容 (content)、填充 (padding)、边框 (border)、边界 (margin)这些属性。我们所说的 width，height 指的是内容 (content) 的宽高。 一个盒子模型的中： 宽度 = width+ padding(宽) + border(宽)。 高度 = height + padding(高) + border(高)。 ","date":"2019-11-05","objectID":"/html/:14:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"15、box-sizing 常用的属性有哪些 ？分别有什么作用 ？ 常用的属性：box-sizing: content-box border-box inherit; 作用： content-box(默认)： 宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。即宽度和高度会变化，内容使用在宽高内部。 border-box： 元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。即宽度高度不会变，内容可能超出宽高。 ","date":"2019-11-05","objectID":"/html/:15:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"16、页面导入样式时，使用 link 和 @import 有什么区别 ？ link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS @import 是 CSS 提供的，只能用于加载 CSS import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题 ","date":"2019-11-05","objectID":"/html/:16:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"17、常见兼容性问题？ 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin: 0; padding: 0;} 来统一。 IE 下 event 对象有 event.x，event.y 属性，而 Firefox 下没有。Firefox 下有 event.pageX，event.PageY 属性，而 IE 下没有。 解决办法：var mx = event.x?event.x:event.pageX; Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. ","date":"2019-11-05","objectID":"/html/:17:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"18、position 、float 和 display 的取值 position 属性取值：static(默认)、relative、absolute、fixed、inherit、sticky float：left (或 right)，向左（或右）浮动 display 属性取值：none、inline、inline-block、block、table 相关属性值、inherit ","date":"2019-11-05","objectID":"/html/:18:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"19、以 CSS3 标准定义一个 webkit 内核浏览器识别的圆角（尺寸随意） -moz-border-radius: 10px; -webkit-border-radius: 10px; border-radius: 10px; ","date":"2019-11-05","objectID":"/html/:19:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"20、优先级算法如何计算？ !important \u003e 写在内联优先级高 \u003eid \u003e class \u003etag 载入样式以最后载入的定位为准 ","date":"2019-11-05","objectID":"/html/:20:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"21、CSS3 新增伪类举例 :after 选择器在被选元素的内容后面插入内容 :before 选择器在被选元素的内容前面插入内容 :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n :nth-child(odd) 奇数 :nth-child(even) 偶数 :nth-child(3n+1) ","date":"2019-11-05","objectID":"/html/:21:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"22、什么是响应式设计 ？响应式设计的基本原理是什么 ？ 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本 基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有 meta 声明的 viewport rem、vw/vh、插件postcss-px-to-viewport 戳戳戳，媒体查询使用方式 \u003cmeta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\u003e width=device-width: 让当前viewport宽度等于设备的宽度 user-scalable=no: 禁止用户缩放 initial-scale=1.0: 设置页面的初始缩放值为不缩放 maximum-scale=1.0: 允许用户的最大缩放值为1.0 minimum-scale=1.0: 允许用户的最小缩放值为1.0 ","date":"2019-11-05","objectID":"/html/:22:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"23、::before 和 :after 中双冒号和单冒号有什么区别 ？解释一下这 2 个伪元素的作用 单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素 ::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中 ","date":"2019-11-05","objectID":"/html/:23:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"23、style 标签写在 body 后与 body 前有什么区别？ 页面加载自上而下，当然是先加载样式。 写在 body 标签后，由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题） ","date":"2019-11-05","objectID":"/html/:24:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["HTML"],"content":"24、rem、em、px、vh 与 vw 的区别 ？ px：表示像素，相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。 em：一个字的高度，是相对长度单位 //1em == 自己font-size的值 rem：root em // 根元素html的font-size vh：viewport height 视口高度=100vh vw：viewport width 视口宽度=100vw ","date":"2019-11-05","objectID":"/html/:25:0","tags":["HTML"],"title":"HTML","uri":"/html/"},{"categories":["WebRTC"],"content":"WebRTC涉及名词和学习资料","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"UDP和TCP TCP和UDP的区别 TCP和UDP的最完整的区别 TCP/UDP协议详解 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:1","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"RTP/RTCP RTP/RTCP协议解析 RTP/RTSP/RTCP有什么区别？ 实时传输协议 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:2","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"SRTP/SRTCP 维基百科：安全实时传输协议 安全实时传输协议（Secure Real-time Transport Protocol或SRTP）是在实时传输协议（Real-time Transport Protocol或RTP）基础上所定义的一个协议，旨在为单播和多播应用程序中的实时传输协议的数据提供加密、消息认证、完整性保证和重放保护。它是由David Oran（思科）和Rolf Blom（爱立信）开发的，并最早由IETF于2004年3月作为RFC 3711发布。 由于实时传输协议和可以被用来控制实时传输协议的会话的实时传输控制协议（RTP Control Protocol或RTCP）有着紧密的联系，安全实时传输协议同样也有一个伴生协议，它被称为安全实时传输控制协议（Secure RTCP或SRTCP）；安全实时传输控制协议为实时传输控制协议提供类似的与安全有关的特性，就像安全实时传输协议为实时传输协议提供的那些一样。 在使用实时传输协议或实时传输控制协议时，使不使用安全实时传输协议或安全实时传输控制协议是可选的；但即使使用了安全实时传输协议或安全实时传输控制协议，所有它们提供的特性（如加密和认证）也都是可选的，这些特性可以被独立地使用或禁用。唯一的例外是在使用安全实时传输控制协议时，必须要用到其消息认证特性。 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:3","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"DTLS DTLS的主要用途，就是让通信双方协商密钥，用来对数据进行加解密。 通信双方：通过DTLS握手，协商生成一对密钥； 发送方：对数据进行加密； 发送方：通过UDP传输加密数据； 接收方：对加密数据进行解密； ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:4","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"STUN/TURN NAT打洞 NAT穿越 P2P穿越 ICE P2P技术之STUN、TURN、ICE详解 WebRTC直播技术(二)-ICE/STUN/TURN WebRTC之STUN、TURN和ICE研究 P2P通信标准协议(一)之STUN ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:5","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"真实的SDP片段 // v 开始会话级描述 v=0 o=- 7017624586836067756 2 IN IP4 127.0.0.1 s=- t=0 0 // m 开始媒体级描述 //下面 m= 开头的两行，是两个媒体流：一个音频，一个视频。 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 126 ... m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116 上面的SDP片段所示，该 SDP 中描述了一路音频流，即m=audio，该音频支持的 Payload ( 即数据负载 ) 类型包括 111、103、104等等。 在该 SDP 片段中又进一步对 111、103、104 等 Payload 类型做了更详细的描述，如 a=rtpmap:111 opus/48000/2 表示 Payload 类型为 111 的数据是 OPUS 编码的音频数据，并且它的采样率是 48000，使用双声道。以此类推，你也就可以知道 a=rtpmap:104 ISAC/32000 的含义是音频数据使用 ISAC 编码，采样频率是 32000，使用单声道。 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:6","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"webRTC脑图 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"参考资料 WebRTC：数据传输相关协议简介 WebRTC：一个视频聊天的简单例子 免费开源项目starRTC WebRTC学习 WebRTC实验 官方文档 ","date":"2019-10-06","objectID":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","tags":["WebRTC"],"title":"WebRTC涉及名词和学习资料","uri":"/webrtc%E6%B6%89%E5%8F%8A%E5%90%8D%E8%AF%8D%E5%92%8C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["WebRTC"],"content":"WebRTC核心API","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"WebRTC核心API可以分为两类 Streams Streams API允许JavaScript以编程的方式访问通过网络接收的数据流，并根据开发人员的需要处理它们。 MediaDevices MediaDevices 接口提供访问连接媒体输入的设备，如照相机和麦克风，以及屏幕共享等。 enumerateDevices() 可用的媒体输入和输出设备的列表，例如麦克风，摄像头，耳机设备。切换设备时用 getDisplayMedia() 选择和授权捕获用户选择的屏幕区域以及一个可选的音频轨道 getStupportedConstraints() 监视客户端所支持的约束属性，比如视频高宽，码率等 getUserMedia() 提示用户授权使用媒体输入，媒体输入会产生MediaStream，里面包含了请求的媒体类型的音视频或其他轨道 如果网页使用了getUserMedia方法，浏览器就会询问用户，是否同意浏览器调用麦克风或摄像头。如果用户同意，就调用回调函数onSuccess；如果用户拒绝，就调用回调函数onError 成功回调函数 获取多媒体设备成功时调用。onSuccess回调函数的参数是一个数据流对象stream。stream.getAudioTracks方法和stream.getVideoTracks方法，分别返回一个数组，其成员是数据流包含的音轨和视轨（track）。 使用的声音源和摄影头的数量，决定音轨和视轨的数量。比如，如果只使用一个摄像头获取视频，且不获取音频，那么视轨的数量为1，音轨的数量为0。每个音轨和视轨，有一个kind属性，表示种类（video或者audio），和一个label属性（比如FaceTime HD Camera (Built-in)）。 失败回调函数 获取多媒体失败时调用。Error对象的code属性有说明错误的类型： PERMISSION_DENIED：用户拒绝提供信息。 NOT_SUPPORTED_ERROR：浏览器不支持硬件设备。 MANDATORY_UNSATISFIED_ERROR：无法发现指定的硬件设备。 //新版本Chrome中getUserMedia接口在http下不再支持。要使用HTTPS协议 navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; //兼容 navigator.getUserMedia({ audio: true, video: { width: 1280, height: 720 } }, (success)=\u003e{ console.log('success'+ success) let video = document.querySelector(\"video\"); // video.src = window.URL.createObjectURL(stream);这种写法已被移除 video.srcObject = stream; }, (error)=\u003e{ console.log('err'+ error) }); // 如果存在回声，应该在video或者audio节点处添加muted，进行简单的回声消噪 demo RTCPeerConnection RTCPeerConnection 接口代表一个由本地计算机到远端的WebRTC连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。 不同客户端之间的音频/视频传递，是不用通过服务器的。但是，两个客户端之间建立联系，需要通过服务器。服务器主要转递两种数据。 通信内容的元数据：打开/关闭对话（session）的命令、媒体文件的元数据（编码格式、媒体类型和带宽）等。 网络通信的元数据：IP地址、NAT网络地址翻译和防火墙等。 var signalingChannel = createSignalingChannel(); var pc; var configuration = ...; // run start(true) to initiate a call function start(isCaller) { pc = new RTCPeerConnection(configuration); // send any ice candidates to the other peer pc.onicecandidate = function (evt) { signalingChannel.send(JSON.stringify({ \"candidate\": evt.candidate })); }; // once remote stream arrives, show it in the remote video element pc.onaddstream = function (evt) { remoteView.src = URL.createObjectURL(evt.stream); }; // get the local stream, show it in the local video element and send it navigator.getUserMedia({ \"audio\": true, \"video\": true }, function (stream) { selfView.src = URL.createObjectURL(stream); pc.addStream(stream); if (isCaller) pc.createOffer(gotDescription); else pc.createAnswer(pc.remoteDescription, gotDescription); function gotDescription(desc) { pc.setLocalDescription(desc); signalingChannel.send(JSON.stringify({ \"sdp\": desc })); } }); } signalingChannel.onmessage = function (evt) { if (!pc) start(false); var signal = JSON.parse(evt.data); if (signal.sdp) pc.setRemoteDescription(new RTCSessionDescription(signal.sdp)); else pc.addIceCandidate(new RTCIceCandidate(signal.candidate)); }; RTCPeerConnection带有浏览器前缀，Chrome浏览器中为webkitRTCPeerConnection，Firefox浏览器中为mozRTCPeerConnection。Google维护一个函数库adapter.js，用来抽象掉浏览器之间的差异。 ","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/:0:0","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"参考链接 MDN Streams API MDN MediaDevices MDN RTCPeerConnection WebRTC 教程 WebRTC – JavaScript 标准参考教程 ","date":"2019-10-04","objectID":"/webrtc%E6%A0%B8%E5%BF%83api/:0:1","tags":["WebRTC"],"title":"WebRTC核心API","uri":"/webrtc%E6%A0%B8%E5%BF%83api/"},{"categories":["WebRTC"],"content":"WebRTC简介","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["WebRTC"],"content":"MDN上对WebRTC是这样说的： WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。 WebRTC的前世今生 on2：主流的桌面及移动应用和设备 提供高质量视频压缩技术 主要视频编解码格式包括 VP3-VP8，被谷歌收购，集成到WebRTC中 Global IP Solutions (GIPS) 的前身为Global IP Sound (GIPS)，专为数据包网络的实时通信应用市场，开发行业领先的嵌入式媒体处理解决方案。 Google 11年收购了它们，开源了 WebRTC项目，推进标准化 2017年11月W3C发布了WebTTC 1.0 webRTC体系架构 这张图来源于webRTC入门，应该每个人最开始接触webRTC时都会知道架构图，它描述了RTCPeerConnection的作用。 图中可以看出一共三个不同的层： web开发人员的API：包括RTCPeerConnection、RTCDataChannel和 MediaStrean对象 浏览器厂商的API 供浏览器厂商以hook方式复写的API 传输组件允许在不同类型的网络中建立连接，而语音视频引擎是负责将音频视频流从声卡和摄像机传输到网络的框架。对于web开发人员来说,最重要的部分是WebRTC API。 ","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/:0:0","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["WebRTC"],"content":"参考链接 Getting Started with WebRTC - HTML5 Rocks ","date":"2019-10-02","objectID":"/webrtc%E7%AE%80%E4%BB%8B/:0:1","tags":["WebRTC"],"title":"WebRTC简介","uri":"/webrtc%E7%AE%80%E4%BB%8B/"},{"categories":["HTML"],"content":"前端性能优化","date":"2019-07-23","objectID":"/web-performance-optimization/","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"网络层面 请求过程的优化 HTTP请求优化 Gzip压缩 //request headers 中加上这么一句 accept-encoding:gzip 图片优化 WebP是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。 减少网络请求 浏览器缓存 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:1","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"渲染层面 服务端渲染 服务端渲染通常是为了SEO，但是服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢。 浏览器的渲染机制 CSS性能方案 JS性能方案 DOM优化 原理和思路 异步循环与异步更新 回流与重绘 首屏渲染 懒加载 ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:2","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["HTML"],"content":"性能监控 可视化工具 Peformance Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。 LightHouse Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。 W3C性能API W3C 规范为我们提供了 Performance 相关的接口。它允许我们获取到用户访问一个页面的每个阶段的精确时间，从而对性能进行分析。我们可以将其理解为 Performance 面板的进一步细化与可编程化。 访问 performance 对象performance 是一个全局对象。 window.performance ","date":"2019-07-23","objectID":"/web-performance-optimization/:0:3","tags":["JavaScript","HTML"],"title":"前端性能优化","uri":"/web-performance-optimization/"},{"categories":["读书"],"content":"这是一本书，《恭喜你，当上主管了》","date":"2019-07-21","objectID":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/","tags":["读书"],"title":"《恭喜你，当上主管了》","uri":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/"},{"categories":["读书"],"content":" 主管推荐了一本书给我，记录下读书笔记。 管理不是靠努力及运气 了解自己和下属 管理前必须先学习“人际沟通”素养和技巧，以及“情绪压力”的处理方式。 “管理机制”、“执行能力\"的知识. 正视自己的工作价值观，面对自我成长的机会。 在职场身份发生改变时，心态和观念也要转变： 从员工变成主管时，最重要的是心态和观念上的转变。 当上主管，在角色上就要将“个人需求”，转化为“员工需求”。 你要带领下属完成部门的工作目标，也就是你要协助部门每一个人完成他们的工作目标。 先管理【人】，在操作【事】。 【事】的管理只是工作目标中的一环； 【人】才是管理的关键 建立良好人际关系互动 真： 真诚的态度，就是能将自己的情感、需求和理念，忠实且适当表达出来，同时也能用于承认自己的错误。 爱：无私的关爱，就是能自由地去接纳并尊重别人，不强迫将自己的价值观加诸于别人身上。 同理心的感受，就是能真正以他人的立场去了解他人，并一定表示同意，而是一种理解别人的能力。 基本上，会影响组织内人际关系的因素，不外乎：沟通渠道和环境、谣言批评和攻击、立场不同、派系斗争、业绩竞争、升迁竞争或是客户间的利害关系。 沟通的三个准则： 要是双向的 不要先入为主 要先处理情绪再处理问题 面对情绪压力 当情绪来时，你可能无法掌握，甚至连自己都难以察觉，继而做出失态的行动，或错误的决策，导致事后后悔。 情绪处理的最好方法是，通过平时的自我管理训练，做一名好的情绪管理者。 当事情很多时，如果没有良好的掌控力和应变力，很容易就会陷入压力的困境。 掌控力：对工作的了解能力和对情绪的处理能力。 应变力：遇到突发事件的变通弹性能力和协调能力。 职场的情绪压力一般来源于： 工作本身 工作负荷过重、危险性高、时间太长或是能力极限 组织发展 指在组织中，受到过多限制、决策独断、缺乏沟通、晋升太快或太慢、无法获得满足感或肯定 人际关系 指与上司、同事或部署的关系不良，或发生冲突等。 个人因素 指个人的性格特质、兴趣、家庭责任及生活危机。 如何处理情绪： 面对它，接受它，处理它，放下它 —圣严法师 做对问题解决。 任何问题发生后，一定要去了解问题的所在，从中学习，找出真正的问题。失败并不可怕，可怕的是我们无法从中吸取教训，学习到宝贵的经验 停看听 停：先冷静面对事情，了解事情的来龙去脉 看： 看看事情的资料和数据，理清问题所在 听： 听听别人的意见，不要自己立即下判断。不要自己闭门造车，或者匆匆忙忙立即下判断。 遇到突发问题，事后要做复盘，那些是可以改善的，能否有做得更好的方式。 ","date":"2019-07-21","objectID":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/:0:0","tags":["读书"],"title":"《恭喜你，当上主管了》","uri":"/%E6%81%AD%E5%96%9C%E4%BD%A0%E5%BD%93%E4%B8%8A%E4%B8%BB%E7%AE%A1%E4%BA%86/"},{"categories":["其他"],"content":"浏览器搜索技巧","date":"2019-06-17","objectID":"/search-skill/","tags":["其他"],"title":"搜索技巧","uri":"/search-skill/"},{"categories":["其他"],"content":" 「+」空格就是加号，搜索 purpose of education 那结果中会有，purpose 和 education 不一定有purpose of education，一些常用的词汇被省略，比如 of the a in and that 等，如果需要这个词出现就用 「+」，my mother +where 「\"\"」完全匹配，“i love fangfang” 搜索就会完全匹配这句话 「-」减号，苹果 -红色，就会搜出不带 “红色” 的苹果 「*」通配符 「~」~单词，自动把这个单词替换成相关的词汇 「OR」或，苹果OR香蕉，要大写，如果 or 则会被忽略 搜索内容后面加 site:zhihu.com，就会在这个域名内搜索 举例： web ~教程 -csdn -cnblogs 或 csdn -site:csdn.net 大家可以去试试 ","date":"2019-06-17","objectID":"/search-skill/:0:0","tags":["其他"],"title":"搜索技巧","uri":"/search-skill/"},{"categories":["Java"],"content":"Java 多线程","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java"],"content":"进程和线程 线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 一个进程可以有很多线程，每条线程并行执行不同的任务。 Java线程 最简单的情况是，Thread/Runnable的run()方法运行完毕，自行终止。 Java中创建线程的方式有两种，不管使用继承Thread的方式还是实现Runnable接口的方式，都需要重写run方法。 //继承Thread类 1、 定义继承Thread; 2、复写Thread类中的run方法;（目的：将自定义代码存储在run方法中，让线程运行（同时运行，抢夺资源）） 3、调用线程的start方法；（目的：启动线程，调用run方法） //实现Runnable接口 1、定义类实现Runnable接口； 2、覆盖Runnable接口中的run方法； 3、通过Thread类建立线程对象； 4、将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法； 5、调用Thread类的start方法，开启线程并调节Runnable接口子类的run方法； //区别： 继承只能继承一个，具有局限性。 继承Thread: 线程代码存放在子类run。 实现runnable: 线程代码存放在接口的子类run。 对于更复杂的情况，比如有循环，则可以增加终止标记变量和任务终止的检查点。 最常见的情况，也是为了解决阻塞不能执行检查点的问题，用中断来结束线程，但中断只是请求，并不能完全保证线程被终止，需要执行线程协同处理。 IO阻塞和等锁情况下需要通过特殊方式进行处理。 使用Future类的cancel()方法调用。 调用线程池执行器的shutdown()和shutdownNow()方法。 守护线程会在非守护线程都结束时自动终止。 Thread有stop()方法，但已不推荐使用。 Java中进程与线程的关系： 运行一个程序会产生一个进程，进程至少包含一个线程。 每个进程对应一个JVM实例，多个线程共享JVM中的堆。 Java采用单线程编程模型，程序会自动创建主线程。 主线程可以创建子线程，原则上要后于子线程完成执行。 多线程 即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。 ","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java"],"content":"为什么需要多线程 现代CPU都是多核的 Java执行模型是同步/阻塞(block)的 默认情况下只有一个进程 处理问题非常自然 但是具有严重的性能问题 开启一个新的线程 Thread Java中只有这么一种东西代表线程 start方法才能并发执行 每多开一个线程，就多一个执行流 方法栈（局部变量）是线程私有的 静态方法/类变量是被所有线程共享的 多线程带来的性能提升 对于IO密集型应用及其有用 网络IO （通常包括数据库） 文件IO 对于CUP密集型应用稍有折扣 性能提升的上线在哪里？ 单核CPU 100% 多核CUP N * 100% 昂贵的线程 能不能使用线程达到无穷无尽的性能提升? 线程的昂贵性在于 CPU切换上下文很慢 线程需要占用内存等系统资源 如果应用一天才几个用户 new Thread().start() 如果应用负载很高 使用线程池： JUC包 线程安全 原子性 共享变量 默认的实现几乎都不是线程安全的 线程不安全的表现 数据错误 i++ if-then-do 死锁 线程安全 实现线程安全的基本手段 不可变类 Integer/String synchronized 同步块 JUC包 AtomicInteger ConcurrentHashMap 任何使用HashMap有线程安全问题的地方，都无脑使用ConcurrentHashMap替换即可 ReentrantLock … 线程池与Callable/Future 什么是线程池 线程池是昂贵的（Java线程模型的缺陷） 线程池是预先定义好的若干个线程 Java中的线程池 Callable/Future 类比Runnable，Callable可以返回值，抛出异常 Future代表一个“未来才会返回的结果” 多线程的经典问题 生产者/消费者模型 解决方法： wait/notify/notifyAll Lock/Condition BlockingQueue ","date":"2019-05-21","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:1","tags":["Java"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["webpack"],"content":"提升 webpack 的构建速度","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"我们来聊聊如何提升 webpack 的构建速度，也许某一天你负责的项目也会到了需要优化 webpack 构建性能的时候。 我们的前端项目随着时间推移和业务发展，页面可能会越来越多，或者功能和业务代码会越来越多，又或者依赖的外部类库会越来越多，这个时候原本不足为道的 webpack 构建时间消耗就会慢慢地进入我们的视野。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:0:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"让 webpack 少干点活 提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"减少 resolve 的解析 在前边第三小节我们详细介绍了 webpack 的 resolve 配置，如果我们可以精简 resolve 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些，下面举个例子，介绍如何在 resolve 这一块做优化： resolve: { modules: [ path.resolve(__dirname, 'node_modules'), // 使用绝对路径指定 node_modules，不做过多查询 ], // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作 // 其他文件可以在编码时指定后缀，如 import('./index.scss') extensions: [\".js\"], // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度 mainFiles: ['index'], }, 上述是可以从配置 resolve 下手提升 webpack 构建速度的配置例子。 我们在编码时，如果是使用我们自己本地的代码模块，尽可能编写完整的路径，避免使用目录名，如：import './lib/slider/index.js'，这样的代码既清晰易懂，webpack 也不用去多次查询来确定使用哪个文件，一步到位。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:1","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"把 loader 应用的文件范围缩小 我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了： rules: [ { test: /\\.jsx?/, include: [ path.resolve(__dirname, 'src'), // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理 // 通常我们需要 loader 处理的文件都是存放在 src 目录 ], use: 'babel-loader', }, // ... ], 如上边这个例子，如果没有配置 include，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:2","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"减少 plugin 的消耗 webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的话，适当地移除掉一些没有必要的 plugin。 这里再提一下 webpack 4.x 的 mode，区分 mode 会让 webpack 的构建更加有针对性，更加高效。例如当 mode 为 development 时，webpack 会避免使用一些提高应用代码加载性能的配置项，如 UglifyJsPlugin，ExtractTextPlugin 等，这样可以更快地启动开发环境的服务，而当 mode 为 production 时，webpack 会避免使用一些便于 debug 的配置，来提升构建时的速度，例如极其消耗性能的 Source Maps 支持。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:3","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"换种方式处理图片 我们在前边的小节提到图片可以使用 webpack 的 image-webpack-loader 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。 这里介绍一种解决思路，我们可以直接使用 imagemin 来做图片压缩，编写简单的命令即可。然后使用 pre-commit 这个类库来配置对应的命令，使其在 git commit 的时候触发，并且将要提交的文件替换为压缩后的文件。 这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:1:4","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"使用 DLLPlugin DLLPlugin 是 webpack 官方提供的一个插件，也是用来分离代码的，和 optimization.splitChunks（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 optimization.splitChunks 即可。 我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 webpack.dll.config.js： module.exports = { name: 'vendor', entry: ['lodash'], // 这个例子我们打包 lodash 作为公共类库 output: { path: path.resolve(__dirname, \"dist\"), filename: \"vendor.js\", library: \"vendor_[hash]\" // 打包后对外暴露的类库名称 }, plugins: [ new webpack.DllPlugin({ name: 'vendor_[hash]', path: path.resolve(__dirname, \"dist/manifest.json\"), // 使用 DLLPlugin 在打包的时候生成一个 manifest 文件 }) ], } 然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 webpack.DllReferencePlugin 配置： module.exports = { plugins: [ new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, 'dist/manifest.json'), // 指定需要用到的 manifest 文件， // webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取 }), ], } 在构建的时候，我们需要优先使用 webpack.dll.config.js 来打包，如 webpack -c webpack.dll.config.js --mode production，构建后生成公共代码模块的文件 vendor.js 和 manifest.json，然后再进行应用代码的构建。 你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 vendor.js 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如： \u003cscript src=\"vendor.js\"\u003e\u003c/script\u003e \u003cscript src=\"main.js\"\u003e\u003c/script\u003e 作用是不是和 optimization.splitChunks 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 webpack.dll.config.js 这一部分的构建，沿用原本的构建结果即可，所以相比 optimization.splitChunks，使用 DLLPlugin 时，构建速度是会有显著提高的。 但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 webpack.dll.config.js 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 optimization.splitChunks 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。 还有一点需要注意的是，html-webpack-plugin 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 add-asset-html-webpack-plugin，关于这一个的使用就不讲解了，详细参考官方的说明文档：使用 add-asset-html-webpack-plugin。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:2:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"webpack 4.x 的构建性能 从官方发布的 webpack 4.0 更新日志来看，webpack 4.0 版本做了很多关于提升构建性能的工作，重要的改进有这么几个： AST 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 PR。 使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。 Node 语言层面的优化，如用 for of 替换 forEach，用 Map 和 Set 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 PRs 寻找更多的内容。 默认开启 uglifyjs-webpack-plugin 的 cache 和 parallel，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。 除此之外，还有比较琐碎的一些内容，可以查阅：webpack release 4.0，留意 performance 关键词。 很显然，webpack 的开发者们越来越关心 webpack 构建性能的问题，有一个关于 webpack 4.x 和 3.x 构建性能的简单对比： 6 entries, dev mode, source maps off, using a bunch of loaders and plugins. dat speed ⚡️ 从这个对比的例子上看，4.x 的构建性能对比 3.x 是有很显著的提高，而 webpack 官方后续计划加入多核运算，持久化缓存等特性来进一步提升性能（可能要等到 5.x 版本了），所以，及时更新 webpack 版本，也是提升构建性能的一个有效方式。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:3:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"换个角度 webpack 的构建性能优化是比较琐碎的工作，当我们需要去考虑 webpack 的构建性能问题时，往往面对的是项目过大，涉及的代码模块过多的情况。在这种场景下你单独做某一个点的优化其实很难看出效果，你可能需要从我们上述提到的多个方面入手，逐一处理，验证，有些时候你甚至会觉得吃力不讨好，投入产出比太低了，这个时候我们可以考虑换一个角度来思考我们遇到的问题。 例如，拆分项目的代码，根据一定的粒度，把不同的业务代码拆分到不同的代码库去维护和管理，这样子单一业务下的代码变更就无须整个项目跟着去做构建，这样也是解决因项目过大导致的构建速度慢的一种思路，并且如果处理妥当，从工程角度上可能会给你带来其他的一些好处，例如发布异常时的局部代码回滚相对方便等等。 这可能有点跑题，但是不得不说，webpack 的确是一个好工具，但总归多多少少会有一些局限性，再怎么优化，不可能总能达到理想的效果，因为它确确实实完成那些构建任务就是需要这么一些时间。作为开发者，面对项目中各种各样的情况要随机应变，灵活处理，不能被好工具捆绑了思维模式，很多问题你不要过于依赖于 webpack，换个角度，可能可以找到更好的处理方式。 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:4:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"总结 减少 resolve 的解析 减少 plugin 的消耗 换种方式处理图片 使用 DLLPlugin 积极更新 webpack 版本 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:5:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["webpack"],"content":"参考 掘金小册 ","date":"2019-05-08","objectID":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/:6:0","tags":["JavaScript","webpack"],"title":"提升webpack的构建速度","uri":"/%E6%8F%90%E5%8D%87webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/"},{"categories":["Web"],"content":"Docker 部署简单的 Web 服务","date":"2019-04-20","objectID":"/docker-deploy-web/","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"Docker 部署 Web ","date":"2019-04-20","objectID":"/docker-deploy-web/:0:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"目录结构 首先，根据以下目录建立对应的文件。 . ├ test.js ├ DockerFile ├ package.json test.js 文件内容如下： const Koa = require('koa'); const app = new Koa(); app.use(function(ctx) { ctx.body = 'hello docker'; }); app.listen(8998); DockerFile 文件内容如下： FROMnodeCOPY . /appWORKDIR/appRUN [\"npm\", \"install\"]EXPOSE3456CMD node test.js ","date":"2019-04-20","objectID":"/docker-deploy-web/:1:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"生成镜像 执行命令生成自定义镜像。 docker image build . -t mytest1 ","date":"2019-04-20","objectID":"/docker-deploy-web/:2:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Web"],"content":"运行容器 将刚刚创建的镜像，通过容器跑起来。 docker container run -p 8000:8998 mytest1 执行完毕之后，在浏览器中直接访问 localhost:8000 就可以看到 hello docker 了。 ","date":"2019-04-20","objectID":"/docker-deploy-web/:3:0","tags":["Docker","Web"],"title":"Docker 部署简单的 Web 服务","uri":"/docker-deploy-web/"},{"categories":["Docker"],"content":"初步学习Docker","date":"2019-03-23","objectID":"/docker-study/","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"什么是Docker Docker是一个开源的应用容器引擎，提供了一种在安全、可重复的环境中自动部署软件的方式，允许开发者将他们的应用和依赖包打包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 ","date":"2019-03-23","objectID":"/docker-study/:0:1","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"Docker基本概念 Docker 包括三个基本概念 镜像（Image） 一个特殊的文件系统 容器（Container） 镜像运行时的实体 仓库（Repository） 集中存放镜像文件的地方 Docker 安装 //deepin 系统 sudo apt-get install docker-ce docker 一些命令 Hello World docker run hello-world 查看docker信息 docker info 启动docker systemctl start docker 重启docker sudo service docker restart 查看容器 docker ps # 查看运行中的容器 docker ps -a # 查看所有容器 列出镜像 docker image ls 查看所有已经创建的包括终止状态的容器 docker container ls -a 镜像体积 docker system df 终止容器 docker container stop 删除容器 docker container rm //删除一个处于终止状态的容器 清理所有处于终止状态的容器 docker container prune 容器操作 # 停止一个容器 docker stop $JOB # 启动一个已经创建的容器 docker start $JOB # 重启一个容器 docker restart $JOB # 停止一个容器 docker kill $JOB # 删除一个容器 docker stop $JOB # 必须先停止 docker rm $JOB 更换国内的 docker 加速器 编辑 /etc/docker/daemon.json 文件，并输入 docker-cn 镜像源地址 { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } 重启docker服务 sudo service docker restart ","date":"2019-03-23","objectID":"/docker-study/:0:2","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["Docker"],"content":"学习资料 Docker — 从入门到实践 Docker基础 从 0 开始了解 Docker ","date":"2019-03-23","objectID":"/docker-study/:1:0","tags":["Docker"],"title":"Docker 基本命令","uri":"/docker-study/"},{"categories":["工具"],"content":"这是描述","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"1、图片背景 https://www.desktoppr.co/ https://alpha.wallhaven.cc/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:1:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"2、图片压缩（可批量） https://tinypng.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:2:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"3、CSS动画效果 http://animista.net/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:3:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"4、文件格式转换 https://smallpdf.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:4:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"5、字体大小转换 http://pxtoem.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:5:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"6、UI设计 http://www.uiimg.com/Material https://dribbble.com/ 交互设计:可以用 Axure RP、墨刀、Sketch.app 视觉设计：可以用 Photoshop、Fireworks、Sketch.app ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:6:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"7、图标 http://www.iconfont.cn/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:7:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"8、图床 https://sm.ms/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:8:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"9、cdn(库) https://cdnjs.com/ https://www.bootcdn.cn/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:9:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"10、鼠标样式大全 http://css-cursor.techstream.org/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:10:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"11、CSS渐变代码生成器 http://www.colorzilla.com/gradient-editor/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:11:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["工具"],"content":"12、JSON格式化工具 http://www.bejson.com/ ","date":"2019-02-16","objectID":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/:12:0","tags":["工具"],"title":"常用在线工具","uri":"/%E5%B8%B8%E7%94%A8%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"categories":["Java"],"content":"Java程序运行流程","date":"2018-09-19","objectID":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/","tags":["Java"],"title":"Java程序运行流程","uri":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["Java"],"content":"java 如何加载的呢 对于Java来说，要执行一个类的main方法，需要先加载它。Java虚拟机规范规定，在加载之后，就要执行方法（java代码的编译过程会把所有的静态初始化块收集到一起在字节码里创建一个方法），所以这一点实际上是类加载的规定。main方法是一个静态方法，所以没有「类的 成员初始化 和 初始化块」发生，除非你接下来使用了new clinit are the static initialization blocks for the class, and static field initialization. 然后再 初始化 类中定义的方法，再执行 main()，最后才是在 heap 里分配一块内存来初始化一个对象（构造函数）—— 执行main的时候没有类的实例产生，所以没有heap内存分配和初始化方法调用发生 java 一个文件就是一个 class，jvm 在解析文件的时候，class 是存在哪里？ 准确的说: Java的一个文件可能编译出来多个class，不过一般而言可以理解成java文件和class文件是一一对应的。class是在heap的一个特殊区域，Java8之前叫“永久代” PermGen，Java8之后叫“元空间” Metaspace，可以理解成专门存放class的地方 「类」 和 「方法」 在内存中初始化和调用？ jvm 是怎么解析一个文件的，程序执行的顺序和在内存分布的情况等 —— 这其实涉及到类加载了, 请去看:《深入了解Java虚拟机》的第七章。 深入理解Java虚拟机.pdf 最最简单的理解是： 当一个类被加载的时候，它自己的空间在堆中被分配（包括static成员，所有的方法字节码包括方法）。随后方法被调用，所有的静态成员得到初始化。这是类加载后立刻发生的事情，发生在main之前。 class文件是一个高度结构化的数据，可以想像成一个JSON文件，只不过人类不可读罢了。JVM读取其中的所有信息，把它们存储在MetaSpace里（“类自己占用的空间”） 当一个方法被调用的时候，JVM在当前线程的方法栈中开辟一个新的栈帧，栈帧的大小由方法的字节码所指定 然后JVM就按照方法字节码指定的指令进行操作 试一试： javap -v -private XXXX.class，它会告诉你类文件的结构。想用图形界面的话，这哥们写了个很有用的工具：[https://github.com/zxh0/classpy]( ","date":"2018-09-19","objectID":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/:0:0","tags":["Java"],"title":"Java程序运行流程","uri":"/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"categories":["Java"],"content":"Java包管理","date":"2018-09-09","objectID":"/java%E5%8C%85%E7%AE%A1%E7%90%86/","tags":["Java"],"title":"Java包管理","uri":"/java%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["Java"],"content":"什么是包 Class（类）是 Java 中的一等公民，所有的 Java 代码，都要写在类里面 在命名规则下，你可以给类起任何名字。当你使用别人的类时，首先知道的是类名，然后再了解如何使用这个类。 随着人们编写的 Java 类越来越多，就会有个问题：如果出现了名字相同的类怎么办？两个名字相同的 User 类，其内涵是否也一样呢？如果不一样，要如何区分它们呢？ Package （包）就是用来解决这个问题的。通过将同名的类放到不同的包里面，我们就可以： 对同名的类进行区分； 精确地指明我们需要其中的哪一个； 让同名的类在一个程序当中共存。 JVM的工作被设计地相当简单： 执行一个类的字节码 假如这个过程中碰到了新的类，加载它 那么，去哪里加载这些类呢？ 类路路径（Classpath） //可以包含多个可供选择的查询路径。每个路径都用分号隔开 -classpath /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/charsets.jar 类的全限定类名（目录层级）唯一确定了一个类 包就是把许多类放在一起的压缩包! 传递性依赖 你依赖的类还依赖了别的类，JVM只认类的说明书（字节码），你要使用一个库，你就得想办法把这份说明书以及它引用的说明书（传递性依赖）找到，然后给JVM。 看上去不是非常困难是不是？想象一下你的程序运行需要一万份说明书吧（传递性依赖的传递性依赖的传递性依赖） Classpath hell 全限定类名是类的唯一标识 当多个同名类同时出现在Classpath中，就是噩梦的开始 什么是包管理 你要使用一些第三方类，总要告诉JVM从哪里找 包管理的本质就是告诉JVM如何找到所需的第三方类库以及成功地解决其中的冲突问题! 包管理发展历程 手动写命令进行编译运行 Apache Ant 手动下载jar包，放在一个目录中 写XML配置，指定编译的源代码目录、依赖的jar包、输出目录等 缺点 每个人都要自己造一套轮子 依赖的第三方类库都需要手动下载，费时费力 假如你的应用依赖了了一万个第三方的类库呢？ 没有解决Classpath地狱的问题 Maven Convention over configuration 约定优于配置 必须强调，Maven远远不止是包管理工具 Maven的中央仓库 按照一定的约定存储包 Maven的本地仓库 默认位于~/.m2 下载的第三方包放在这里进行缓存 Maven的包 按照约定为所有的包编号，方便检索 groupId/artifactId/version 传递性依赖的自动管理 原则： 绝对不允许最终的classpath出现同名不不同版本的jar包 依赖冲突的解决：原则：最近的胜出 依赖的scope 当你看到如下的异常的时候 AbstractMethodError NoClassDefFoundError ClassNotFoundException LinkageError ","date":"2018-09-09","objectID":"/java%E5%8C%85%E7%AE%A1%E7%90%86/:0:0","tags":["Java"],"title":"Java包管理","uri":"/java%E5%8C%85%E7%AE%A1%E7%90%86/"},{"categories":["Java"],"content":"重载（Overload）和重写（Override）的区别","date":"2018-08-19","objectID":"/java-overload/","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"重载(Overload) 前提： 所有的重载函数必须在同一个类中 重载方法的规则： 参数列表：被重载的方法必须改变参数列表。 返回类型：可以改变返回类型。 修饰符：可以改变修饰符。 异常：可以声明新的或者更广泛的异常。 其中： 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 同名不同参数 public class Demo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } ","date":"2018-08-19","objectID":"/java-overload/:1:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"重写（Override） 前提： 继承 重写的规则： 参数列表：必须与被重写方法的参数列表完全匹配。 返回类型：必须与超类中被重写的方法中声明的返回类型或子类型完全相同 访问级别：一定不能比被重写方法强，可以比被重写方法的弱。 非检查异常：重写方法可以抛出任何非检查的异常，无论被重写方法是否声明了该异常。 检查异常：重写方法一定不能抛出新的检查异常，或比被重写方法声明的检查异常更广的检查异常。 不能重写标志为final, static的方法。 其中： 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。 若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。 子类重写的函数的访问修饰权限不能低于父类的。 同名同参数 //父类 public class ParentDemo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } //子类 public class childrenDemo extends ParentDemo{ public void go(){ System.out.println(\"go1\"); } public void go(String a){ System.out.println(\"go1\"); } public void go(String a, String b){ System.out.println(\"go1\"); } } 构造器constructor是否可以被重写？ 父类的私有方法不能被继承，构造器是不能被继承的，所以就不能被重写。在同一个类中，构造器是可以被重载的 ","date":"2018-08-19","objectID":"/java-overload/:2:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":["Java"],"content":"总结 重载和重写（覆盖）。 方法的重写（Overriding）和重载（Overloading）是Java多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。 Overloaded的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。 ","date":"2018-08-19","objectID":"/java-overload/:3:0","tags":["Java"],"title":"重载（Overload）和重写（Override）的区别","uri":"/java-overload/"},{"categories":[""],"content":"在windows 和 Unix 上calsspath separator 上是不同的","date":"2018-08-17","objectID":"/classpath-separator/","tags":["",""],"title":"在windows 和 Unix 上calsspath separator 上是不同的","uri":"/classpath-separator/"},{"categories":[""],"content":"calsspath separator 在windows和Unix 上是不同的windows上是分号 直接写java -cp .;junit-4.12.jar Main是会报错的，因为分号代表命令的结束，所以需要用引号括起来 shell不负责命令的解释，它会把这个path原封不动地交给java去处理 git bash 还是windows上的java，所以还是按照分号去分割，只能丢引号里传给java 在unix系统里，分号用于分割两个shell命令 所以这个事情的坑爹之处就在于，git bash里的命令是遵循Unix系统的约定，但是传递给Java程序的classpath分隔符需要遵循windows系统的约定 另外：在cmd上不用引号 javac -cp junit-XXX.jar Main.java这个命令是什么 这个命令里，javac是executable，他的参数是classpath，Main.java是“即将被编译的文件”。Main.java中有一个ActiveTestSuite，那么这个类肯定不能从天上掉下来，要去哪儿找呢，就只能去-cp指定的地方找。 java命令 java -cp .;junit-XXX.java Main Main代表“告诉JVM，要从Main类启动JVM”，那么Main类从哪儿找呢？只能从-cp指定的地方找。JVM运行Main的时候发现，这个引用了ActiveTestSuite，那这个类去哪儿找？也只能从-cp里找 ","date":"2018-08-17","objectID":"/classpath-separator/:0:0","tags":["",""],"title":"在windows 和 Unix 上calsspath separator 上是不同的","uri":"/classpath-separator/"},{"categories":["Java"],"content":"Java异常","date":"2018-08-13","objectID":"/java%E5%BC%82%E5%B8%B8/","tags":["Java"],"title":"Java异常","uri":"/java%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"Java 异常 异常是什么 ： Java异常是Java提供的一种识别及响应错误的一致性机制。是对问题的描述，将问题进行对象的封装。 异常的好处： Java异常机制可以使程序中异常处理代码和正常业务代码分离，在有效使用异常 的情况下，异常能清晰的回答what,where,why这3个问题：异常类型回答了“什么 ”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。 异常两大体系： 异常类都是Throwable的子类。而在Throwable下有两个子类： Error：指的是JVM错误，指此时的程序还没有执行，如果没有执行用户无法处理。 Exception：指的是程序运行中产生的异常，用户可以处理。 * Throwable （所有异常都是从Throwable继承而来。） * Error(错误，无毒) * Exception - checked execption （受检异常，有毒，代表一种预料之中的异常，IOException） * RuntimeException （运行时异常，无毒，代表一种预料之外的异常，因此不需要声明） * catch的级联与合并 异常的抛出原则 能用if/else处理的，不要使用异常 尽早抛出异常 异常要准确、带有详细信息 抛出异常也比悄悄执行错误的逻辑强得多 throw/throws throw 抛出一个异常，用于抛出异常。 throws 只是一个声明，用在方法签名中，用于声明该方法可能抛出的异常。 异常的处理原则 本方法是否有责任处理这个异常？ 不要处理不归自己管的异常 本方法是否有能力处理这个异常？ 如果自己无法处理，就抛出 如非万分必要，不要忽略异常 异常的处理 try / catch / finally 如果没有try，异常将击穿所有的栈帧 catch可以将一个异常抓住 finally执行清理工作 JDK7+： try-width-resources try{ // 有可能出现异常的语句 } [catch(异常类型 对象) { // 处理异常 } catch(异常类型 对象) { // 处理异常 } catch(异常类型 对象) { // 处理异常 } ... ] [finally { // 不管是否出现异常，都执行的统一代码 }] JDK内置的异常 NullPointerException (空指针异常) 调用了未经初始化的对象或者是不存在的对象 ClassNotFoundException (指定的类不存在) NumberFormatException (字符串转换为数字异常) 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据\"111\"转换为数值型数据时，是允许的。但是如果字符型数据中包含了非数字型的字符，“111aa111\"转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理. ClassCastException (数据类型转换异常) IllegalStateException IllegalArgumentException (方法的参数错误) IllegalAccessException (没有访问权限) 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常 IndexOutOfBoundsException (数组下标越界异常) ArithmeticException (数学运算异常) FileNotFoundException (文件未找到异常) 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出。即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 ArrayStoreException (数组存储异常) 当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常 Object[] obj = new String[3]; obj[0] = new Integer(0); NoSuchMethodException (方法不存在异常) 当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 OutOfMemoryException (内存不足错误) 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 等等 ","date":"2018-08-13","objectID":"/java%E5%BC%82%E5%B8%B8/:0:1","tags":["Java"],"title":"Java异常","uri":"/java%E5%BC%82%E5%B8%B8/"},{"categories":["Java"],"content":"Java面向对象","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"对象 对象的行为 —-可以对对象施加那些操作，或可以对对象施加那些方法？ 对象的状态 —-当施加那些方法时，对象如何响应？ 对象标识 —-如何辨别具有相同行为与状态的不同对象？ 类 类（class）是构造对象的模板。由类构造对象的过程称为创建类的是实例。 一个类以 public class开头，public class 代表这个类是公共类，类名必须和文件名相同 public class Merchandise { //类体中可以定义描述这个类的属性的变量。 （成员变量） Sting name; String id; int count; double price; } public class SuperMarket{ public static void main(String[] args){ //使用new操作符，可以创建一个类的实例/对象（instance/object） //使用new创建一个类的实例后，类中定义的每种变量都会被赋以其类型的初始值。 Merchandise m1 = new Merchandise(); //赋值 m1.name = \"这是第一个name\"; m1.id = \"000001\"; m1.count = 10000; m1.print = 88.8; } } 封装 继承 多态 Java是一门面向对象的编程语言，除了基本数据类型以外，Java要求每一个数据类型必须都是一个类。 面向对象的编程思想力图使在计算机语言中对事物的描述与现实世界中该事物的本来面目尽可能地一致，类（class）和对象（object）就是面向对象方法的核心概念。 类是对某一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称实例（Instance）。类和对象就如同概念和实物之间的关系一样，类就好比是一个模板，而对象就是该模板下的一个实例。 面向对象的主要思想是：将客观事物看作具有状态和行为的对象，通过抽象找出同一类对象的共同状态和行为，构成类。 在Java当中申明类都是由class开头的。 ","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"参考 零基础学Java ","date":"2018-05-29","objectID":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["Java"],"title":"Java面向对象","uri":"/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Java"],"content":"java基本结构","date":"2018-04-25","objectID":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","tags":["Java"],"title":"Java基本结构","uri":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":" java基本结构 从上到下分为: 包 ** 类** （存放代码基本单元）， 类中包含： ** 静态成员** ** 静态方法** ** 实例变量 ** ** 实例方法** 静态变量 存放在jvm中全局的存储单元， 被所有的有访问权限的对象共享。 静态方法 静态方法可以直接通过类名调用，任何的实例也都可以调用 实例方法 通过对象的实例来调用。 成员变量 和一个对象绑定 在自己类内部可以直接访问 静态变量和静态方法，再别的类中，必须加上类型来访问 ","date":"2018-04-25","objectID":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/:0:0","tags":["Java"],"title":"Java基本结构","uri":"/java%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"},{"categories":["读书"],"content":"清醒思考的艺术","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"《清醒思考的艺术》 人是生而自由的，却无往不在枷锁之中。用这句话来描述人类为思维错误所累的情形，也十分恰当精到。思维错误、认知陷阱就像是伴生于人类，细追究起来无处不在，不经意之时又无迹可寻。难道人们注定就要戴着无形的“有色眼镜”看世界吗？不，人们可以思考自己的思考，拒绝思考被污染。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:0:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"自序 我们高估我们的学识要比低估我们的学识频繁的多。失去某种东西的危险要比获得某种东西的前景更能促使我们加快速度。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:1:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"1 幸存偏误 幸存偏误：由于日常生活中更容易看到成功，看不到失败你会系统性地高估成功的希望。 幸存偏误意味着：你系统性地高估了成功概率。 解决办法：尽可能去逛逛曾经大有希望的项目、投资和事业的墓地。这样的散步虽然伤感，但对你是有好处的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:2:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"2 游泳选手身材是错觉 一种错觉:职业游泳者体型完美,并不是因为他们锻炼充分。实际情况正好相反：他们之所以成为出色的游泳选手，是因为他们拥有这样的身材。他们的身躯是一种选择标准，而不是他们运动的结果。 结论：凡有人讴歌某种东西值得追求——强健肌肉、美貌、高收入、长寿、影响力、快乐，你都要看仔细。在跨入泳池之前，不妨先照照镜子。你要诚实地看待自己。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:3:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"3 过度自信效应 我们总是系统性地高估我们的学识和预测能力——而且高估的很厉害。对于过度自信效应，重要的不是单个估计是否正确。过度自信会令你忽视你真正知道的东西与你已知的东西之间的区别。 不存在相反的人不够自信效应。 过度自信效应在男人身上比女人深深更明显——女人较少高估自己。 不仅悲观者会受到过度自信效应的影响，就连自称悲观的人也会高估自己——只不过高估的幅度要少些罢了。 结论：请对所有预测持怀疑态度，尤其是当这些预测是由所谓的专家们作出的。请你在筹建任何事情时都从悲观的角度出发，作最坏的打算。这样你才会真正有机会，更现实一些地判断形势。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:4:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"4 从众心理 从总心理（随大溜）：只要别人做什么我也跟着做什么，我的行为就是正确的。换言之，越多的人认为一个想法正确，这个想法就更加正确——这当然是荒谬的。 英国作家毛姆这样讲到：“就算有5000万人声称某件蠢事是对的，这件蠢事也不会因此成为聪明之举。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:5:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"5 纠缠于沉没成本 每个决定，不管是私人的还是业务上的，始终是在不确定的 情况下作出的。我们的设想，有可能兑现，也有可能落空、任何 时候我们都可能离开选取的小道，并承担后果，比如中断项目。 这种不确定情形下的权衡是理性行为。然而，在我们已经投人特 别多的时间、金钱、能置、爱等因素之后，沉没成本令人难以放 手、难以释怀。于是已经投资的钱就成了继续做下去的理由，即 使客观来看坚持下去毫无意义。投资越多，沉没成本就越大，将 项目继续做下去的理由就越充分。 股市投资人经常成为沉没成本的受害者。他们在决定是否出 售股票时常以买人价作为参照。当股价髙于买入价时，就卖掉股 票；如果股价低于买入价，就抱住不卖。这是不理智的，绝不可 以让买入价处处扮演角色。唯一有效的是股市未来的前景（和可 选投资未来的行情）。每个人都会出错，特别是在股市里。纠缠于 沉没成本的不幸，其关键就是：你投资一只股票亏的钱越多，你 越是抱紧它不放。 为什么会有这种荒谬行为呢？因为人类想努力表现得坚韧， 坚韧是我们发出的可信信号。我们害怕矛盾。如果我们决定中断 —个项目，我们就在制造矛盾：承认从前的想法与今天不同。继 续执行一个无意义的项目是在推迟这一疼痛认识。那样我们就显得更坚韧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:6:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"6 互惠偏误 互惠是风险管理；没有互惠，人类——还有无数种动物——早就灭绝了。 互惠也有可恶的一幕：报复。紧接着报复的是反报复，然后你就会陷入一种恶性循环中。 最近，一个女人向我解释了她在酒吧里为什么不让别人请她 喝饮料：“因为我不想要这种跟他上床的潜在义务。”这样做很明 智。如果下回在超市里有人主动跟你搭讪，让你品尝葡萄酒、奶 酪、火腿或橄榄，你就知道你为什么最好是拒绝他了。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:7:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"7 确认偏误之一 确认偏误是所有思维错误之父一它倾向于这样诠释新信息， 让它们与我们现有的理论、世界观和信念相兼容。换句话说：我们过滤掉与我们的现有观点相矛盾（因此被称作反驳证据，不过 它缺少合适的德语表达）的新信息，这是危险的。赫胥黎说过： “事实不因为被忽视而消失。”但我们恰恰是这么做的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:8:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"8 确认偏误之二 结论：请你与确认偏误作斗争。请你写下你的信条一有关 世界观、投资、婚姻.健康预防措施、节食、成功策略的，然后 寻找反驳证据。干掉自己最心爱的理论，这是一桩艰苦的工作， 但作为聪明人士，你不会躲避的. ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:9:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"9 权威偏误 不管什么时候遇到一位专家，我都会设法向他挑战。请你也这么做。你对权威的批判性越强，你就越自由，就越相信自己有更多的能力。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:10:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"10 对比效应 但对比效应在别处也有效。试验表明，为了节约10欧元，人 们会走10分钟的路去购买一种食物。可是，如果能在街道另一端 花979欧元而不是989欧元买一套西服，谁也不会想到要去走这 10分钟的路，这是一种非理性的行为，因为10分钟还是10分钟， 10欧元还是10欧元 对比效应有时能够毁掉你的整个生活：一个漂亮女人嫁给了 一个相当普通的男人。为什么？因为她的父母都很厉害，她觉得 普通男人更好，虽然他实际上并没有那么好。最后：在超级名模 的广告轰炸下，就连漂亮女人都会觉得自己魅力一般•因此，如 果你是女人，想找一个男人，你千万不要让你的模特儿等级的朋 友陪你一起出去。男人会因此发觉不到你的真实魅力。你独自去 就好。更好的办法是：你带上两个比你难看的朋友去参加舞会。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:11:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"11 现成偏误 你为什么宁可用一张错误的地图，也不愿没有地图 现成偏误是指：我们依据现成的例子来想象世界。这当然是愚蠢的，因为外界现实中的某种东西不会因为我们更容易想到而出现得更频繁。 **壮观、华丽或大声的一切，我们都高估了它们出现的概率。而无声、无形的一切，我们都低估了它们出现得概率。**因为我们的大脑更容易接受壮观、华丽或大声的东西。我们的大脑的剧本式思维的，而不是量化思维的。 应对方法：请与你想法不同的人合作，跟那些与你拥有截然不同经验的人合作。因为你独自战胜不了现成偏误。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:12:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"12 “在好转之前先恶化\"的陷阱 如果有人建议你选择一条“先经历痛苦的道路”，你应该敲响警钟 结论：如果有人说：“在好转之前先恶化”，你脑子里就应该敲响警钟。不过请小心：确实有那样的情形，先是再次下滑然后回升。事业的转换可能会耗费时间，会照成停发工资。一个企业的重组也需要一定的时间。但所有这些情况，人们很快能出措施是否有效。里程碑是明确的，是可以检测的。请你望着里程碑，而不是望着天空 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:13:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"13 故事偏误 结论：从自传到世界大事——我们将一切炮制成有“意义”的故事。我们这样做是在扭曲真相——这会影响我们决定的质量。应对方法：请你将这些故事拆解开来。请你问问自己：这些故事想隐藏什么？训练方法：**请你设法用无关联的眼光看看自己的生平，**你会吃惊的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:14:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"14 事后诸葛亮偏误 事后诸葛亮偏误为什么这么危险呢？因为它让我们相信自己是很好的预言家，而事实却不是这样。这会导致我们傲慢，误导我们作出错误的决定。 但我还有一个建议，这建议更多是来自个人经验而不是科学：请你记日记。请你写下你的预测——有关政治、事业、体重、股市等。请你不时拿你的记载与实际情况相比较。你会惊讶你是个多么糟糕的预言家。另外，请你同样读历史。不是事后的、成熟的理论，而是那个时代的日记、简报、备忘录。这会让你更好地感觉到世界的不可预见性。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:15:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"15 司机的知识 你为什么不可以把新闻播音员说的话当真 查理·芒格认为：知识有两种：一种是真知识，来自那些投入大量时间和思考以获得知识的人们；另一种就是司机的知识，司机是指那些装得好像他们知道的人。他们会模仿别人表演，他们也可能拥有动听的声音或具有说服力的形象。但他们传播的知识是空洞的，他们高谈阔论地挥霍着华丽词汇。 能力范围：在这个范围之内的，人们都像专家一样精通。在这个范围之外的，就不懂或只懂一部分。巴菲特的生活信条是：“请认清你的能力范围，并待在里面。这个范围有多大，并不重要，重要的是知道这个范围的界限在哪里。” 你必须找出自己的才能在哪里。我几乎可以向你保证，如果你必须在你的能力范围之外碰运气，你的职业生涯将会非常糟糕。 真正有知识的人知道他们知道什么，也知道他们不知道什么。这类人一旦来到他的“能力之外”，他要么什么也不说，要么就说“我不知道”。他这么说时不会觉得难为情，甚至还会带着一定的骄傲。而从“司机们”那儿，你别的什么话都能听到，就说听不到这一句。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:16:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"16 控制错觉 控制错觉是指：相信我们能够控制或影响某种我们客观上无法控制或影响的倾向。 请你将注意力集中于你真正能影响的少量东西——坚定不移地只关注其中最重要的那些。其他的，听之任之吧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:17:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"17 激励过敏倾向 人们会对激励机制做出反应。这不奇怪。人都会做对自己有益的事情。令人吃惊的是两个次要方面：第一，一旦有激励加入游戏或改变了激励，人们就会迅速而剧烈地改变自己的行为；第二，人们是对激励做出的反应，而不是对激励背后的目的做出反应。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:18:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"18 回归均值 极端成绩与不太极端的成绩总是来回交替。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:19:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"19 公地悲剧 凡好处归个人而成本由集体承担的地方，就潜伏着公地悲剧。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:20:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"20 结果偏误 结论：请你切勿以结果判断决定。结果差不一定意味着当时所作的决定不对，反之亦然。你最好仔细研究一下这样作决定的原因，而不是吐槽一个被证明是错误的决定，或者为一个也许是纯属偶然地获得成功的决定感到庆幸。这个决定是出于理性而作出的吗？如果是，那你下回最好仍然这么做，哪怕上回的结果很糟。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:21:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"21 选择的悖（bei)论 选择范围太大会导致无所适从 选择范围大会导致作出更差的决定。 选择范围大会导致不满。 怎么办？请你在端详面前的选项之前，仔细考虑你想要什么。请你写下你的标准，并务必遵守它们。你要明白，你永远作不出完美的选择。要想作出在事后看来无懈可击的选择是非理性的，因为事情的发展永远有无数种可能性。你就满足于一个适合你的“好答案”吧。是的，在生活伴侣这件事上也是如此。只有最好的才适合你吗？在存在无限选择的年代，情况恰恰相反：适合你的才是最好的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:22:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"22 讨喜偏误 讨喜偏误：指的是某人越讨喜，我们就越倾向于从这个人那儿买东西或者帮助他。 什么是讨喜： 外表有吸引力 在出身、个性和兴趣上与我们相似 他觉得我们讨人喜欢 这三个因素是依次排列的。 结论：你在判断一笔生意时应该坚持不受卖方影响。请你不要考虑他，更好的办法是：请你想象他是个不不讨人喜欢的家伙。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:23:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"23 禀赋效应 禀赋效应：我们感觉我们拥有的东西比我们没有拥有的更有价值。 我们拥有某种东西的事实显然赋予了这样东西额外的价值 请不要死抱着某种东西不放，请将你拥有的视作“宇宙”临时留给你的某种东西。要知道你拥有的一切随时又会被拿走。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:24:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"24 奇迹 不可能事件的必然性 不可思议的意外事件就是虽然少见但完全可能发生的事件。它们的发生没什么可吃惊的，如果它们从不发生，那才令人感到意外。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:25:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"25 团体迷思 共识为什么有可能是危险的 结论：如果你是一个智囊团的成员，无论何时，你都要讲出你的看法——哪怕这看法不是很中听。你要仔细考虑没有讲出的意见，必要时要冒着被隔离在温暖团体之外的风险。如果你领导着一支团队，请你指定某人唱反调。他将不是团队中最受欢迎的人，但也许是最重要的人。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:26:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"26 忽视概率偏误 我们是对一件事的预期强度做出反应，而不是对它的概率。 忽视概率偏误：缺少对概率的直觉理解。 结论： 我们很难区分各种风险，除非风险为零。由于我们不能直觉地理解风险，我们必须计算。在概率公开的地方——像彩票——这就很容易。而在普通生活中，风险很难估计，但又是躲也躲过的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:27:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"27 零风险偏误 零风险偏误：几乎在所有的情况下，人们本来都能更好地投资这笔钱，更显著地降低另一种风险。 结论：请你告别零风险的想象，学会怀着“没有什么是安全的”想法生活——无论是你的积蓄、你的健康、你的婚姻、你的友谊、你的敌人，还是你的土地。请你满足于至少有东西让你保证相对稳定并体验自身的快乐，研究表明，无论是中了百万彩票还是半身瘫痪都不会长期改变你的满意程度。不管发生什么事，快乐的人照样快乐，不快乐的人依旧不快乐。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:28:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"28 稀少性谬误 结论：我们对稀少性的典型反应是丧失清晰思考的能力。因此请你仅按照价格和作用判断一样东西。你不要在乎它是否稀少，是否有其他人也想要它。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:29:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"29 忽视基本概率 精确的描述误导了我们，让冷静的目光偏离了统计真相。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:30:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"30 赌徒谬论 赌徒谬论：人们相信命运具有一种平衡力量。但独立事件不存在平衡的力量。 结论：请你仔细观看，看你面对的是否是独立的事件——不过这主要存在于赌场、彩票和理论的书籍里。现实生活中这些事件大多有着相互联系——已经发生的事情，会影响未来将要发生的事情。因此请你忘记命运的平衡力量（除了回归均值的情形）。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:31:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"31 锚定效应？ 现实生活中，锚定效应随处可见。科学证明，如果老师知道一位学生过去的学习成绩，就会影响他给学生的新论文打分。在这里，过去的成绩起了锚定的作用。许多产品在包装袋上刊印的“建议销售价”也是一个锚定。职业销售人员知道，他们必须先设定一个锚——远在他们报价之前。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:32:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"32 归纳法？ “除了死亡和税收，没有什么是肯定的。” 归纳法有可能具有诱惑性：“人类一直都是成功的，因此我们也将征服未来的挑战。”听起来不错，但我们没有考虑：只有那些幸存到现在的物种才能这么说。以我们存在的事实来说明将来我们也会存在，这是一个严重的思维错误——估计是最严重的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:33:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"33 规避损失？ 规避损失：损失要比同样多的收益对我们的影响更大。 人们害怕失去某种东西的想法要比获得同等价值的东西的想法强烈。 我们无法改变：恶比善更有影响力。我们对不利的东西的反应要比对有利的东西的反应敏感。走在大街上，一张凶恶的脸要比一张友善的脸更容易引起我们的注意。恶性要比善行更久地留存在我们的记忆里。当然也有例外：在事关我们自己的时候。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:34:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"34 社会性懈怠？ 社会性懈怠是一种理性行为：假如使出一半力就行，又不会引起注意，为什么要使出全力呢？ 社会性懈怠是一种让我们自己亏欠所有人的欺骗陌生。这一欺骗大多不是故意的，而是不知不觉地发生的。 可以通过尽可能彰显个人效率，来缓和团队的弊病。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:35:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"35 指数增长？ 结论：当事关增长率时，请不要相信你的感觉。你的感觉是没有用的——请你承认这一点。真正有助与你的是计算器，或者，在增长率小的时候，就是用计算倍增时间的诀窍。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:36:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"36 赢家的诅咒？ 赢家的诅咒：拍卖的赢家大多是事实的输家。 “千万不要参与拍卖。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:37:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"37 基本特征谬误？ 基本特征谬误是指，系统性地高估人的影响，在解释某些东西时低估情境因素。 我们必须理解基本特征谬误：极度关注他人源自我们过去的进化史，隶属于一个群体是生存所必需的，被排斥意味着死亡。繁殖、自卫和狩猎，大多是个体做不到的。我们需要别人协助。特立独行的人——其中肯定有一些——早就在基因池里消失了。因此我们才会这样过度地关注人。我们将90%的精力都用来关注人，只用10%的精力关注情境。 结论：不管戏剧多么让我们着迷，舞台上的人绝非孤立的，他们的表演离不开一个个情境。你要真想理解正在表演的戏剧，就请你不要只注重表演者，而是多关注他们的表演或舞蹈。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:38:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"38 错误的因果关系？ “良好的员工激励会创造更高的企业利润”？果真如此吗？ 相互关系不等于因果关系 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:39:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"39 光环效应？ 光环效应的作用方式总是一样：我们容易得到的或特别明显的因素，自动推论到更难查明的特性。于是，我们倾向于认为一家声誉良好的制造商的产品质量更好，虽然没有客观理由证明此事。 结论：光环效应挡住了我们的视线，让我们看不到真实的特征。因此你要看仔细。请你排除醒目的特征。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:40:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"40 替代途径？ 结论： 风险从来不是一眼就能看到的。因此，请你时刻考虑你有什么样的替代途径。比起你通过无惊险的平凡途径（辛苦工作）获得的成功，别拿通过冒险的替代途径获得的成功太当真。蒙田怎么说来着：“我的生命充满不幸——这些不幸大多没有发生。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:41:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"41 预测的错觉？ “预言未来的人有两种：一种是一无所知的人，另一种是不知道他们自己一无所知的人。” 问题是：专家不必为错误预测付出代价——无论是以金钱损失还是以失去好名声的形式。 结论：请你对预测持批评态度。 英国前首相托尼·布莱尔说：“我不作语言。我从没做过，我永远不会做” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:42:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"42 关联谬误？ 结论：请你忘记“左半脑和右半脑”的说法吧，更重要的是直觉思维和有意识思维之间的区别。直觉思维偏好可信的故事，作重要决定时不顺从它们对你是有好处的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:43:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"43 框架效应？ 结论：你要意识到，没有框架效应，你什么也不能描述，每个事实——不管你是从一位朋友那儿听到的，还是在一份严肃的报刊上读到的——都会受到框架效应的影响。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:44:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"44 行动偏误？ 即使毫无用处，也要采取行动。 社会更喜欢下意识的行动，而不是喜欢有意义的等待。 结论：在不明情形下我们会产生要做点什么的冲动，随便什么——不管它有没有帮助。之后我们会感觉好受些，虽然其实什么也没有好转——事实甚至往往相反。因此，如果情况不明，请你不要采取任何行动，直到你能更好地分析形势。你要克制自己。“人类的全部不幸就是他们不能安静地待在他们的房间里。”帕斯卡尔就曾经这么写到，在他的书房里。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:45:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"45 不作为偏误？ 不作为偏误总是出现在无论放弃还是行动都会带来损害的地方。在这种情况下大多数人都会选择放弃，因为这样引起的损害主观看起来更无害。 不作为偏误很难辨认——放弃行动不像采取行动那么容易看出。我们不得不承认，1968年的欧洲学生运动看穿了不作为偏误，提出了一个醒目的口号来反对它：“如果你不是答案的一部分，你就是问题的一部分。” （如果你不解决问题，那你等于就是在延续问题、加重问题）当然也就成了“问题的一部分” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:46:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"46 自利偏误？ 成功归于自己，失败归于外因。这就是自利偏误。 如何应对自利偏误呢？你有对你直言不讳的朋友吗？如果有，你很幸运。如果没有，那你至少有个死对头吧？好，那你就挑战一下自己，请他喝咖啡，请他不加掩饰地说出对个人的意见。你会永远感激他的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:47:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"47 享乐适应症？ 事业上迈进了一步的人在平均3个月后的幸福感又与先前一样了。就连那些非要驾驶最新款保时捷的人也一样。科学里称这一效应为享乐适应症：我们工作、升迁，给自己购买更多更漂亮的东西，但我们不会变得更幸福。 请你避免很长时间也不会习惯的负面效应，例如往返交通、噪音、慢性疲累等； 请你对物质的东西只期待短期效果，例如汽车、房屋、分红、中彩票、得奖金等； 持续的正面效应主要与你如何利用你的时间有关。 你要设法让自己得到尽可能多的自由时间和自主全。请你做你最爱做的事情——哪怕你要付出部分收入。请你为友谊投资。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:48:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"48 自我选择偏误？ 但我们本身是样品的一部分是，我们必须注意，不要掉进一种以自我选择偏误著称的侍卫错误的陷阱中。 男性抱怨公司女性太少，女性抱怨公司男性太少，这与倒霉毫无关系，因为抱怨着是样品的一部分。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:49:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"49 联想偏误？ 为什么经验有时让人变蠢。 广告将产品与积极的情感联系在了一起。因此你永远不会看到可口可乐与一张不满的脸或一个苍老的身体出现在一起。喝可口可乐的人总是年轻、漂亮、无比快乐。 联想偏误会影响我们作决定的质量。 马克·吐温说：“我们应该注意，一个经历里隐藏了多少智慧，我们就只吸取多少——不要多；好让我们不像坐过热灶台的猫一样。被烫过的猫永远不会再坐到热灶台上去——这是对的；但它永远不会再坐到冷灶台上去了。” ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:50:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"50 新手的运气？ 假如开始时一起顺利，请务必多加小心。 下面是联想偏误的一种特殊情况：错误地与从前的成功建立联系。赌场的赌客熟悉这一点，他们称这是新手的运气。在游戏的前几轮就输掉的人会倾向于退出游戏；而赢钱的人，就倾向于继续玩下去。这个幸运儿坚信自己拥有超过平均水平的能力，于是他会加大赌注——后来他一下就变成了倒霉蛋，也就是在概率“正常化”的时候。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:51:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"51 认知失调？ 你如何撒点小谎，让自己的感觉好一些。 极不理性的自欺欺人，只能用认知失调来解释。 你还可以尽情地扮演那只狡猾的狐狸——因为你没有吃到葡萄 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:52:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"52 双曲贴现？ 及时行乐——但请只限于星期天 随着时间长度的不同，我们作出的决定是不一致的。科学里称这一现象为双曲贴现。意思是：一个决定离现在越近，我们的“情感利息”就越多。 结论：及时行乐的诱惑力极大——尽管如此，双曲贴现也是一种思维错误。我们越能控制我们的冲动，我们就能成功规避这一错误。我们对我们的冲动控制越小——比如在酒精的影响下——我们就越容易犯这个错误。及时行乐是个好主意——如果每星期一次的话。但天天享受，好像每天都是末日似的，却是不明智的。 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:53:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["读书"],"content":"结尾 在群体里容易按照他人的想法生活，在孤独中容易按照自己的想法生活。但值得记住的只是那些在群体中保持独立的人。——爱默生 清醒思考是奢侈的 ","date":"2018-03-23","objectID":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/:54:0","tags":["读书"],"title":"《清醒思考的艺术》","uri":"/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"},{"categories":["Java"],"content":"Java运算符","date":"2018-03-09","objectID":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":["Java"],"title":"Java运算符","uri":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Java"],"content":" 运算符对一个或者多个值进行运算，并得出一个运算结果 运算符的运算结果类型有的是固定的，有时候会根据被计算的值变化。比如两个int想加，结果类型就是int。两个byte相加，返回值就是byte。 算术运算符 算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。有加减乘除，取余，自加自减。 public class Test { public static void main(String[] args) { int a = 10; int b = 20; int c = 25; int d = 25; System.out.println(\"a + b = \" + (a + b) ); System.out.println(\"a - b = \" + (a - b) ); System.out.println(\"a * b = \" + (a * b) ); System.out.println(\"b / a = \" + (b / a) ); System.out.println(\"b % a = \" + (b % a) ); System.out.println(\"c % a = \" + (c % a) ); System.out.println(\"a++ = \" + (a++) ); System.out.println(\"a-- = \" + (a--) ); // 查看 d++ 与 ++d 的不同 System.out.println(\"d++ = \" + (d++) ); System.out.println(\"++d = \" + (++d) ); } } 关系运算符 == //是否相等 如果相等则条件为真 != //是否相等 如果值不相等则条件为真 \u003e //检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 \u003c //检查左操作数的值是否小于右操作数的值，如果是那么条件为真。 \u003c= //检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 \u003e= //检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 逻辑运算符 逻辑运算符有 \u0026\u0026 逻辑与, || 逻辑或， ! 逻辑非。 public class Test { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println(\"a \u0026\u0026 b = \" + (a\u0026\u0026b)); System.out.println(\"a || b = \" + (a||b) ); System.out.println(\"!(a \u0026\u0026 b) = \" + !(a \u0026\u0026 b)); } } 赋值运算符 常用到的赋值运算符有 = 等于 += 加等于 -= 减等于 *= 乘等于 /= 除等于 等等。 其他运算符 - 条件运算符（三元运算符） - instanceof 运算符 ​ ​ 运算符优先级 () ! *,/,% +,- \u003c=,\u003c,\u003e=,\u003e == != \u0026,\u0026\u0026,|,|| = 位运算符 Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符主要针对二进制，它包括了：“与”、“非”、“或”、“异或”。从表面上看似乎有点像逻辑运算符，但逻辑运算符是针对两个关系运算符来进行逻辑运算，而位运算符主要针对两个二进制数的位进行逻辑运算。 ","date":"2018-03-09","objectID":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["Java"],"title":"Java运算符","uri":"/java%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["Java"],"content":"Java语句和循环","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"条件语句 if-else语法 if-else语法，只有一个语句被执行 if和else都是Java中的关键字 if(boolean 值){ if语句块 }else{ else语句块 } if(boolean 值){ if语句块 }else if(){ if语句块 }else{ else语句块 } switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } ","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/:0:1","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"循环结构 顺序结构的程序语句只能被执行一次。如果您想要同样的操作执行多次,，就需要使用循环结构。 Java中有三种主要的循环结构： while 循环 while( 布尔表达式 ) { //循环内容 } public class Test { public static void main(String args[]) { int x = 10; while( x \u003c 20 ) { System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); } } } do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 do { //代码语句 }while(布尔表达式); public class Test { public static void main(String args[]){ int x = 10; do{ System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); }while( x \u003c 20 ); } for 循环 让程序在满足某条件时，重复执行某个代码块。for是Java中的关键字 for(初始化; 循环体条件表达式; 循环体后语句) { //代码语句 } public class Example { //for 循环 public static void main(String[] args) { for (int i = 1; i \u003c= 9; i++) { String line = \"\"; for (int j = 1; j \u003c= 9; j++) { if (j \u003e i) { break; } line += i + \"*\" + j + \"=\" + (i * j) + \"\\t\"; } System.out.println(line); } } } public class Example { //for 循环 public static void main(String[] args) { for (int i = 1; i \u003c= 9; i++) { for (int j = 1; j \u003c= i; j++) { System.out.printIn(i + \"*\" + j + \"=\" + (i * j) + \"\\t\") } } System.out.printIn('\\n') } } ","date":"2018-02-22","objectID":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/:1:0","tags":["Java"],"title":"Java语句和循环","uri":"/java%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF/"},{"categories":["Java"],"content":"Java基本数据类型","date":"2018-02-18","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["Java"],"title":"Java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Java"],"content":"基本数据类型有： byte 字节型 short 短整型 int 整型 long 长整型 float 单精度浮点 double 双精度浮点 char 字符型 boolean 布尔型 可以分为三类： 数值类型：byte、 short、 int、 long、 float、 double 字符类型：char 布尔型：boolean byte 1、byte是8位的数据类型，占用一个字节（8bit)，默认值是0，它的取值范围是(-2^7) ~ (2^7-1)，也就是 -128 ~ 127之间，所以最大存储数据量是255; 2、byte一般在大型数组中使用，来代替整数，因为byte变量占用的空间只有int的1/4 short 1、short是16位的数据类型，占用2个字节，默认值是0，它的取值范围是(-2^15) ~(2^15-1)，也就是 -32768 ~ 32767之间，所以最大数据存储量是65536; 2、short虽然是int型变量所占空间的1/2，但是在实际中却很少用到。在大型数组中也可以节省空间。 int 1、int是32位的数据类型，占用4个字节，默认值是0，它的取值范围是(-2^31) ~(2^31-1)，也就是 -2147483648 ~ 2147483647之间，所以最大数据存储量是2^32-1; 2、int是数据类型是整型，是我们在项目中用到最多的数据类型之一; long 1、long是64位的数据类型，占用8个字节，默认值是0L，它的取值范围是(-2^63) ~(2^63-1)，也就是 -9223372036854775808 ~ 9223372036854775808之间，所以最大数据存储量是2^64; 2、long是数据类型是长整型，是我们在项目中用到最多的数据类型之一。在使用long类型的数据时最好在数值末尾带上大写的L！ 3、long 使用示例:long a=1000L,long b=-2000L; float 1、float是32位的数据类型，占用4个字节，默认值是0，它的取值范围是3.4e-45 ~ 1.4e38 之间; 2、float是数据类型是单精度，在直接赋值时必须在数字后加上f或F。 3、float使用示例:float a=10.25f, float b=-20.35F; double 1、double是64位的数据类型，占用8个字节，默认值是0，它的取值范围是4.9e-324 ~ 1.8e308 之间; 2、double是数据类型是双精度，在直接赋值的时候最好加上D或d。 3、double使用示例:double a=10.123d, double b= -10.25644D; boolean 1、boolean是布尔类型，占用1个字节，只有两个值,false和true，默认值是 false。 2、boolean只能用一种标志来记录 true或false，一般和 if 结合使用。 3、boolean使用示例: boolean a=true，boolean b=false; char 1、char是字符类型，占用2个字节，默认值为空，取值范围 为 0~65535，也就是 \\u0000 ~ \\uffff。 2、char数据类型可以储存任何字符。 3、char 使用示例: char a=1，char b='A’; ","date":"2018-02-18","objectID":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Java"],"title":"Java基本数据类型","uri":"/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":[],"content":"Ubuntu配置Java环境","date":"2017-10-06","objectID":"/ubuntu16.04-study/","tags":["Java"],"title":"Ubuntu16 配置Java环境","uri":"/ubuntu16.04-study/"},{"categories":[],"content":"添加源 添加ppa sudo add-apt-repository ppa:webupd8team/java sudo apt-get update 安装oracle-java-installer sudo apt-get install oracle-java8-installer 设置系统默认jdk sudo update-java-alternatives -s java-8-oracle 官网下载JDK文件jdk-8u171-linux-x64.tar.gz 创建一个目录作为JDK的安装目录 sudo mkdir /java 把下载的文件移入/java目录下 cd 下载地址目录 sudo mv jdk-8u171-linux-x64.tar.gz /java 解压文件 sudo tar -zxvf jdk-8u171-linux-x64.tar.gz 配置环境变量 sudo gedit /etc/environment 在末尾加入JAVA_HOME的路径，即： PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin\" CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib JAVA_HOME=/java/jdk1.8.0_171 保存退出后在运行 source /etc/environment //使环境变量立即生效 或者重启命令行 测试 ▶ java -version openjdk version \"1.8.0_171\" OpenJDK Runtime Environment (build 1.8.0_171-8u171-b11-2-b11) OpenJDK 64-Bit Server VM (build 25.171-b11, mixed mode) ~ ▶ javac -version javac 1.8.0_171 ","date":"2017-10-06","objectID":"/ubuntu16.04-study/:1:0","tags":["Java"],"title":"Ubuntu16 配置Java环境","uri":"/ubuntu16.04-study/"},{"categories":[],"content":"Win7 安装 Mongodb","date":"2017-09-23","objectID":"/win7-install-mongodb/","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"下载安装 mongodb官网下载地址：[hhttps://www.mongodb.com/download-center](https://www.mongodb.com/download-center) 直接下载.msi文件并安装到指定目录即可。我的安装路径是D:\\mongodb 然后在根目录下新建一个blog文件夹，作为数据存放目录（网上的教程多命名为data，你们随意，自己知道就行）。 同时在根目录下新建一个logs文件夹，作为日志文件存放处。 现在看起来可能是这样子的： |-D: |-mongodb |- blog |- logs ","date":"2017-09-23","objectID":"/win7-install-mongodb/:1:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"设置系统变量 这一步的目的在于可以直接在cmd控制台执行mongod命令，而不需要一路cd到\\bin目录才能执行。 我的电脑--属性--高级系统设置--环境变量--系统变量，找到PATH，双击编辑，在末尾加上;D:\\MongoDB，注意前面加分号，最后点击确定即可 ","date":"2017-09-23","objectID":"/win7-install-mongodb/:2:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"启动mongodb 现在，我们可以直接cmd打开命令行，直接输入 mongod --dbpath=D:\\MongoDB\\blog，若输出的末尾有这一句则代表mongodb已经成功启动，端口号为27017。 我们在浏览器输入localhost:27017，页面将显示“It looks like you are trying to access MongoDB over HTTP on the native driver port.”表示启动成功。 这时候新开一个命令行窗口，就可以直接执行mongo的指令了。 ","date":"2017-09-23","objectID":"/win7-install-mongodb/:3:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"更快捷的方式 通过以上步骤，我们解决了“一路cd”的问题，但是启动mongodb还是需要写mongod --dbpath=D:\\MongoDB\\blog。 我们可以把mongodb作为开机启动任务，随系统开启而开启！ 打开cmd控制台，输入 mongod --dbpath=D:\\mongodb\\blog --logpath=D:\\mongodb\\logs\\mongodb.log --install 这时候在\\logs文件夹内就会出现一个mongodb.log文件，里面是mongodb的一些日志。 现在mongodb已经可以随系统启动了。以后我们需要连接mongodb数据库，只需要在cmd控制台输入net start mongodb， 需要关闭mongodb，只需要输入net stop mongodb ","date":"2017-09-23","objectID":"/win7-install-mongodb/:4:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":[],"content":"下载msi 默认安装 安装mongodb服务端 示例安装目录：C:\\Program Files\\MongoDB 用管理员打开命令行： Win+R--\u003ecmd 创建mongodb数据库和日志文件目录（自定在c盘下创建data文件夹） mkdir c:\\data\\db mkdir c:\\data\\log 创建配置文件（日志配置、数据库配置） echo logpath=c:\\data\\log\\mongod.log\u003e \"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\" echo dbpath=c:\\data\\db\u003e\u003e \"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\" 创建mongodb服务（创建后自动生成服务 services.msc） sc.exe create MongoDB binPath= \"\\\"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.exe\\\" --service --config=\\\"C:\\Program Files\\MongoDB\\Server\\3.0\\bin\\mongod.cfg\\\"\" DisplayName= \"MongoDB\" start= \"auto\" 启动mongodb服务 net start MongoDB ","date":"2017-09-23","objectID":"/win7-install-mongodb/:5:0","tags":["JavaScript"],"title":"Win7 安装 Mongodb","uri":"/win7-install-mongodb/"},{"categories":["JavaScript"],"content":"npm 一些配置","date":"2017-08-23","objectID":"/npm-config/","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm 小技巧 运行 npm config set loglevel http， npm 发出的请求 运行 npm config set progress false，关闭进度条 运行 npm config set registry https://registry.npm.taobao.org/ 这会让你在运行 npm adduser 的时候出问题，想要恢复成原样，只需要 npm config delete registry 即可 还原 npm config set registry https://registry.npmjs.org/ ","date":"2017-08-23","objectID":"/npm-config/:0:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"清除缓存 npm cach clean --force ","date":"2017-08-23","objectID":"/npm-config/:1:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"node-sass 安装失败 $ npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ ","date":"2017-08-23","objectID":"/npm-config/:2:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"chromedriver_win32 下载失败 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver ","date":"2017-08-23","objectID":"/npm-config/:3:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm scripts 规则 \"scripts\": { \"lint\": \"eslint --fix --ext .js,.vue src\", }, eslint --fix 可以按照eslint规则自动格式化 Module build failed: Error: No parser and no file path given, couldn’t infer a parser 的错误。 rm -rf node_modules npm install npm install prettier@~1.12.1 ","date":"2017-08-23","objectID":"/npm-config/:4:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["JavaScript"],"content":"npm 常用的包 nodemon bcrypt jsonwebtoken http-assert pm2 ","date":"2017-08-23","objectID":"/npm-config/:5:0","tags":["npm","JavaScript"],"title":"npm 常见的一些配置","uri":"/npm-config/"},{"categories":["HTML"],"content":"使用原生JavaScript完成一个Tab切换 ","date":"2017-03-09","objectID":"/javascript-tab/:0:0","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"代码结构 ","date":"2017-03-09","objectID":"/javascript-tab/:1:0","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"html \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003cli\u003e选项4\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003cli\u003e内容4\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cdiv class=\"tab\"\u003e \u003cul class=\"tab-header clearfix\"\u003e \u003cli class=\"active\"\u003e选项1\u003c/li\u003e \u003cli\u003e选项2\u003c/li\u003e \u003cli\u003e选项3\u003c/li\u003e \u003cli\u003e选项4\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"tab-container\"\u003e \u003cli class=\"active\"\u003e内容1\u003c/li\u003e \u003cli\u003e内容2\u003c/li\u003e \u003cli\u003e内容3\u003c/li\u003e \u003cli\u003e内容4\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ","date":"2017-03-09","objectID":"/javascript-tab/:1:1","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"css ul, li { margin: 0; padding: 0; } li { list-style: none; } .clearfix:after { content: ''; display: block; clear: both; } .tab { width: 600px; margin: 20px auto; border: 1px solid #ccc; padding: 20px 10px; border-radius: 4px; } .tab-header { border-bottom: 1px solid #ccc; } .tab-header\u003eli { float: left; color: brown; border-top: 1px solid #fff; border-left: 1px solid #fff; border-right: 1px solid #fff; padding: 10px 20px; cursor: pointer; } .tab-header .active { border: 1px solid #ccc; border-bottom-color: #fff; border-radius: 4px 4px 0 0; color: #333; margin-bottom: -1px; } .tab-container { padding: 20px 10px; } .tab-container\u003eli { display: none; } .tab-container\u003e.active { display: block; } .box { height: 1000px; } ","date":"2017-03-09","objectID":"/javascript-tab/:1:2","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"js let headerList = document.querySelectorAll('.tab-header li'); let panelList = document.querySelectorAll('.tab-container li'); //forEach的callback传入三个参数：currentValue、index、array headerList.forEach(function(headerLi){ headerLi.onclick = function(e){ //当点击当前元素是，所有的元素去掉active let currentLi = e.target; headerList.forEach(function(li){ li.classList.remove('active'); }) //当前的元素加上active类,由于headerList是类数组对象所以需要call数组方法indexOf let index = [].indexOf.call(headerList,currentLi); headerList[index].classList.add('active'); //隐藏所有panelList，并显示当前panel panelList.forEach(function(panel){ panel.classList.remove('active'); }) panelList[index].classList.add('active'); } }) ","date":"2017-03-09","objectID":"/javascript-tab/:1:3","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"jQuery $('.tab-header\u003eli').on('click',function(){ let $this = $(this); $panels = $this.parents('.tab').find('.tab-container\u003eli'), index = $(this).index(); $this.siblings().removeClass('active'); $this.addClass('active'); $panels.removeClass('active'); $panels.eq(index).addClass('active'); }) ","date":"2017-03-09","objectID":"/javascript-tab/:1:4","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"},{"categories":["HTML"],"content":"封装 function Tab(ct) { this.ct = ct; this.init(); this.bind(); } Tab.prototype.init = function () { this.headerList = this.ct.querySelectorAll('.tab-header\u003eli'); this.panelList = this.ct.querySelectorAll('.tab-container\u003eli'); } Tab.prototype.bind = function () { let _this = this; //把this暂存起来 this.headerList.forEach(function (headerLi) { headerLi.onclick = function (e) { let currentLi = e.target; _this.headerList.forEach(function (li) { li.classList.remove('active'); }) let index = [].indexOf.call(_this.headerList, currentLi); _this.headerList[index].classList.add('active'); _this.panelList.forEach(function (panel) { panel.classList.remove('active'); }) _this.panelList[index].classList.add('active'); } }) } let tab1 = new Tab(document.querySelectorAll('.tab')[0]); let tab2 = new Tab(document.querySelectorAll('.tab')[1]); let tab3 = new Tab(document.querySelectorAll('.tab')[2]); //当创建了对象之后就会创建一个空对象，然后把这个对象的_proto_属性指向Tab.protitype。然后再将 //执行构造函数里的this初始化。 ","date":"2017-03-09","objectID":"/javascript-tab/:1:5","tags":["JavaScript","HTML"],"title":"HTML + JS 的一个 Tab切换","uri":"/javascript-tab/"}]